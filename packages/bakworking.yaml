# ###############################################################################
# # SVOTC – Stable Core Edition (2026-02)  ✅ FULL CODE 
# #
# # INNEHÅLL:
# #   1. UI / Controls (Helpers)
# #      - Comfort settings
# #      - Engine outputs
# #      - Price controls
# #      - Dwell times
# #      - Brake phase settings
# #      - Entity mapping
# #      - State machine memory
# #      - Timestamps
# #
# #   2. Sensing & Planning Sensors
# #      2.1 Indoor temperature (validated)
# #      2.2 Outdoor temperature (validated)
# #      2.3 Current price (validated)
# #      2.4 Dynamic target temperature
# #      2.5 Percentiles P30/P80
# #      2.6 Raw price state (instant)
# #      2.7 Forward look (minutes to brake)
# #      2.8 Prebrake window & strength
# #      2.9 Virtual outdoor temperature
# #      2.10 Binary sensors (comfort guard, inputs healthy, price available)
# #
# #   3. Automations (State Machines)
# #      3.1 Price dwell (raw → stable)
# #      3.2 Brake phase controller
# #      3.3 Engine (requested → applied offset)
# #
# # Purpose: Stable + explainable SVOTC core with strict layering...

# ###############################################################################
# # 1. UI / Controls (Helpers)
# ###############################################################################

# input_select:
#   svotc_mode:
#     name: "SVOTC Mode"
#     options: ["Off", "Smart", "PassThrough", "ComfortOnly"]

# input_number:
#   # --- Comfort ---
#   svotc_comfort_temperature:
#     name: "Comfort temperature"
#     min: 15
#     max: 25
#     step: 0.1
#     mode: box

#   svotc_comfort_guard_activate_below_c:
#     name: "Comfort guard activate (below target)"
#     min: 0.2
#     max: 3.0
#     step: 0.1
#     mode: box

#   svotc_comfort_guard_deactivate_above_c:
#     name: "Comfort guard deactivate (above target)"
#     min: 0.1
#     max: 2.0
#     step: 0.1
#     mode: box

#   # --- Engine outputs (helpers act as "state memory") ---
#   svotc_requested_offset_c:
#     name: "Requested offset (engine)"
#     min: -10
#     max: 10
#     step: 0.1
#     mode: box

#   svotc_applied_offset_c:
#     name: "Applied offset (ramp-limited)"
#     min: -10
#     max: 10
#     step: 0.1
#     mode: box

#   svotc_max_delta_per_step_c:
#     name: "Max delta per minute"
#     min: 0.05
#     max: 1.0
#     step: 0.01
#     mode: box

#   # --- Price controls ---
#   svotc_brake_aggressiveness:
#     name: "Brake aggressiveness"
#     min: 0
#     max: 5
#     step: 1
#     mode: slider

#   svotc_heat_aggressiveness:
#     name: "Heat aggressiveness"
#     min: 0
#     max: 5
#     step: 1
#     mode: slider

#   # --- Dwell times (minutes) ---
#   svotc_price_dwell_cheap_to_neutral_min:
#     name: "Dwell cheap → neutral (min)"
#     min: 0
#     max: 120
#     step: 5
#     mode: box

#   svotc_price_dwell_neutral_to_brake_min:
#     name: "Dwell neutral → brake (min)"
#     min: 0
#     max: 120
#     step: 5
#     mode: box

#   svotc_price_dwell_brake_to_neutral_min:
#     name: "Dwell brake → neutral (min)"
#     min: 0
#     max: 120
#     step: 5
#     mode: box

#   svotc_price_dwell_neutral_to_cheap_min:
#     name: "Dwell neutral → cheap (min)"
#     min: 0
#     max: 120
#     step: 5
#     mode: box

#   # --- Brake phase settings ---
#   svotc_brake_rampup_duration_min:
#     name: "Brake ramp-up duration (min)"
#     min: 1
#     max: 180
#     step: 5
#     mode: box

#   svotc_brake_hold_duration_min:
#     name: "Brake hold duration (min)"
#     min: 1
#     max: 120
#     step: 10
#     mode: box

#   svotc_brake_rampdown_duration_min:
#     name: "Brake ramp-down duration (min)"
#     min: 1
#     max: 180
#     step: 5
#     mode: box

#   svotc_brake_hold_offset_c:
#     name: "Brake hold offset (°C)"
#     min: 0
#     max: 10
#     step: 0.1
#     mode: box

# input_text:
#   # Entity mapping (user-friendly)
#   svotc_entity_indoor:
#     name: "Indoor temperature entity"
#     initial: "sensor.inomhusmedel"

#   svotc_entity_outdoor:
#     name: "Outdoor temperature entity"
#     initial: "sensor.temperatur_nu"

#   svotc_entity_price:
#     name: "Price entity (Nordpool/Tibber HACS style)"
#     initial: "sensor.nordpool_tibber"  # <--- Ändra tili din elprissensor
#     # Must provide attributes:
#     #   current_price
#     #   raw_today (list of {start, end, value})
#     #   raw_tomorrow (list of {start, end, value})

#   # State machine memory
#   svotc_last_price_state:
#     name: "Stable price state (authoritative)"
#     initial: "neutral"

#   svotc_pending_price_state:
#     name: "Pending price state (dwell)"
#     initial: "neutral"

#   svotc_brake_phase:
#     name: "Brake phase"
#     initial: "idle"   # idle / ramping_up / holding / ramping_down

#   svotc_reason_code:
#     name: "Reason code"
#     initial: "INIT"

# input_datetime:
#   svotc_last_price_state_changed:
#     name: "Pending state since"
#     has_date: true
#     has_time: true

#   svotc_brake_phase_changed:
#     name: "Brake phase changed"
#     has_date: true
#     has_time: true

# ###############################################################################
# # 2. Sensing & planning sensors (NO memory via this.state)
# ###############################################################################

# template:
#   - sensor:
#       #########################################################################
#       # 2.1 Indoor temperature (validated)
#       #########################################################################
#       - name: "SVOTC Src Indoor"
#         unique_id: svotc_src_indoor
#         unit_of_measurement: "°C"
#         device_class: temperature
#         state_class: measurement
#         state: >
#           {% set ent = states('input_text.svotc_entity_indoor') %}
#           {% set ent = ent if ent not in ['unknown','unavailable',''] else 'sensor.inomhusmedel' %}
#           {% set v = states(ent) | float(none) %}
#           {{ v | round(2) if v is number and 10 <= v <= 35 else none }}
#         availability: >
#           {% set ent = states('input_text.svotc_entity_indoor') %}
#           {% set ent = ent if ent not in ['unknown','unavailable',''] else 'sensor.inomhusmedel' %}
#           {{ states(ent) | float(none) is number }}

#       #########################################################################
#       # 2.2 Outdoor temperature (validated)
#       #########################################################################
#       - name: "SVOTC Src Outdoor"
#         unique_id: svotc_src_outdoor
#         unit_of_measurement: "°C"
#         device_class: temperature
#         state_class: measurement
#         state: >
#           {% set ent = states('input_text.svotc_entity_outdoor') %}
#           {% set ent = ent if ent not in ['unknown','unavailable',''] else 'sensor.temperatur_nu' %}
#           {% set v = states(ent) | float(none) %}
#           {{ v | round(2) if v is number and -50 <= v <= 50 else none }}
#         availability: >
#           {% set ent = states('input_text.svotc_entity_outdoor') %}
#           {% set ent = ent if ent not in ['unknown','unavailable',''] else 'sensor.temperatur_nu' %}
#           {{ states(ent) | float(none) is number }}

#       #########################################################################
#       # 2.3 Current price (validated)  -> "source of truth"
#       #########################################################################
#       - name: "SVOTC Src Current Price"
#         unique_id: svotc_src_current_price
#         unit_of_measurement: "SEK/kWh"
#         state: >
#           {% set ent = states('input_text.svotc_entity_price') %}
#           {% set ent = ent if ent not in ['unknown','unavailable',''] else 'sensor.nordpool_tibber' %}
#           {% set p = state_attr(ent, 'current_price') %}
#           {{ p | round(3) if p is number and -1 <= p <= 20 else none }}
#         availability: >
#           {% set ent = states('input_text.svotc_entity_price') %}
#           {% set ent = ent if ent not in ['unknown','unavailable',''] else 'sensor.nordpool_tibber' %}
#           {{ state_attr(ent, 'current_price') is number }}

#       #########################################################################
#       # 2.3b Current price (mirror) -> exists for dashboards/legacy references
#       #########################################################################
#       - name: "SVOTC Current price"
#         unique_id: svotc_current_price
#         unit_of_measurement: "SEK/kWh"
#         state: "{{ states('sensor.svotc_src_current_price') }}"
#         availability: "{{ states('sensor.svotc_src_current_price') not in ['unknown','unavailable','none',''] }}"

#       #########################################################################
#       # 2.4 Dynamic target temperature
#       #########################################################################
#       - name: "SVOTC Dynamic target temperature"
#         unique_id: svotc_dynamic_target_temperature
#         unit_of_measurement: "°C"
#         device_class: temperature
#         state: "{{ states('input_number.svotc_comfort_temperature') | float(21) | round(2) }}"

#       #########################################################################
#       # 2.5 Percentiles P30/P80 from raw_today + raw_tomorrow
#       #      (NO memory fallback; outputs none when insufficient data)
#       #########################################################################
#       - name: "SVOTC P30"
#         unique_id: svotc_p30
#         unit_of_measurement: "SEK/kWh"
#         state: >
#           {% set ent = states('input_text.svotc_entity_price') %}
#           {% set ent = ent if ent not in ['unknown','unavailable',''] else 'sensor.nordpool_tibber' %}
#           {% set today = state_attr(ent, 'raw_today') | default([], true) %}
#           {% set tomorrow = state_attr(ent, 'raw_tomorrow') | default([], true) %}
#           {% set prices = (today + tomorrow) | map(attribute='value') | select('number') | list %}
#           {% if prices | length >= 20 %}
#             {% set s = prices | sort %}
#             {% set idx = ((s | length - 1) * 0.30) | round(0, 'half_up') | int %}
#             {{ s[idx] | round(3) }}
#           {% else %} {{ none }} {% endif %}

#       - name: "SVOTC P80"
#         unique_id: svotc_p80
#         unit_of_measurement: "SEK/kWh"
#         state: >
#           {% set ent = states('input_text.svotc_entity_price') %}
#           {% set ent = ent if ent not in ['unknown','unavailable',''] else 'sensor.nordpool_tibber' %}
#           {% set today = state_attr(ent, 'raw_today') | default([], true) %}
#           {% set tomorrow = state_attr(ent, 'raw_tomorrow') | default([], true) %}
#           {% set prices = (today + tomorrow) | map(attribute='value') | select('number') | list %}
#           {% if prices | length >= 20 %}
#             {% set s = prices | sort %}
#             {% set idx = ((s | length - 1) * 0.80) | round(0, 'half_up') | int %}
#             {{ s[idx] | round(3) }}
#           {% else %} {{ none }} {% endif %}

#       #########################################################################
#       # 3. Raw price state (instant, NO dwell, NO memory)
#       #    Thresholds: current_price vs P30/P80
#       #########################################################################
#       - name: "SVOTC Raw price state"
#         unique_id: svotc_raw_price_state
#         state: >
#           {% set mode = states('input_select.svotc_mode') %}
#           {% if mode in ['Off','PassThrough','ComfortOnly'] %}
#             off
#           {% else %}
#             {% set p = states('sensor.svotc_src_current_price') | float(none) %}
#             {% set p30 = states('sensor.svotc_p30') | float(none) %}
#             {% set p80 = states('sensor.svotc_p80') | float(none) %}
#             {% if p is number and p80 is number and p > p80 %}
#               brake
#             {% elif p is number and p30 is number and p < p30 %}
#               cheap
#             {% else %}
#               neutral
#             {% endif %}
#           {% endif %}

#       #########################################################################
#       # 4a. Forward look: minutes to next brake start (price > P80)
#       #########################################################################
#       - name: "SVOTC Minutes to next brake start"
#         unique_id: svotc_minutes_to_next_brake_start
#         unit_of_measurement: "min"
#         state: >
#           {% set ent = states('input_text.svotc_entity_price') %}
#           {% set ent = ent if ent not in ['unknown','unavailable',''] else 'sensor.nordpool_tibber' %}
#           {% set today = state_attr(ent, 'raw_today') | default([], true) %}
#           {% set tomorrow = state_attr(ent, 'raw_tomorrow') | default([], true) %}
#           {% set combined = today + tomorrow %}
#           {% set p80 = states('sensor.svotc_p80') | float(none) %}
#           {% set now_ts = as_timestamp(now()) %}
#           {% set ns = namespace(best=none, in_expensive=false) %}
        
#           {% if p80 is number %}
#             {# 1) If we are inside an expensive interval right now -> treat as active block #}
#             {% for it in combined %}
#               {% set v = it.value | float(none) %}
#               {% set s = as_timestamp(it.start, default=none) if it.start is defined else none %}
#               {% set e = as_timestamp(it.end,   default=none) if it.end   is defined else none %}
#               {% if v is number and s is number and e is number and s <= now_ts < e and v > p80 %}
#                 {% set ns.in_expensive = true %}
#               {% endif %}
#             {% endfor %}
        
#             {% if ns.in_expensive %}
#               0
#             {% else %}
#               {# 2) Otherwise: minutes until the next expensive start #}
#               {% for it in combined %}
#                 {% set v = it.value | float(none) %}
#                 {% set s = as_timestamp(it.start, default=none) if it.start is defined else none %}
#                 {% if v is number and s is number and s >= now_ts and v > p80 %}
#                   {% set mins = (s - now_ts) / 60 %}
#                   {% if ns.best is none or mins < ns.best %}
#                     {% set ns.best = mins %}
#                   {% endif %}
#                 {% endif %}
#               {% endfor %}
#               {{ ns.best | round(1) if ns.best is not none else 999 }}
#             {% endif %}
#           {% else %}
#             999
#           {% endif %}
      
#       #########################################################################
#       # 4b. Prebrake window calculation (aggressiveness → minutes)
#       #########################################################################
#       - name: "SVOTC Prebrake window (min)"
#         unique_id: svotc_prebrake_window_min
#         unit_of_measurement: "min"
#         state: >
#           {% set a = states('input_number.svotc_brake_aggressiveness') | int(0) %}
#           {% set mapper = {0:0, 1:30, 2:60, 3:90, 4:105, 5:120} %}
#           {{ mapper.get(a, 0) }}

#       - name: "SVOTC Prebrake strength"
#         unique_id: svotc_prebrake_strength
#         state: >
#           {% set window = states('sensor.svotc_prebrake_window_min') | float(0) %}
#           {% set mins = states('sensor.svotc_minutes_to_next_brake_start') | float(999) %}
#           {% if window > 0 and mins <= window %}
#             {{ ((window - mins) / window) | round(3) | clamp(0, 1) }}
#           {% else %}
#             0
#           {% endif %}

#       #########################################################################
#       # 5. Virtual outdoor temperature (uses applied offset helper)
#       #########################################################################
#       - name: "SVOTC Virtual outdoor temperature"
#         unique_id: svotc_virtual_outdoor_temperature
#         unit_of_measurement: "°C"
#         device_class: temperature
#         state: >
#           {% set out = states('sensor.svotc_src_outdoor') | float(none) %}
#           {% set off = states('input_number.svotc_applied_offset_c') | float(0) %}
#           {% if out is number %}
#             {{ (out + off) | clamp(-50, 50) | round(2) }}
#           {% else %}
#             {{ none }}
#           {% endif %}

#   - binary_sensor:
#       #########################################################################
#       # 6a. Comfort guard (with hysteresis) - TRUE binary sensor
#       #########################################################################
#       - name: "SVOTC Comfort guard active"
#         unique_id: svotc_comfort_guard_active
#         state: >
#           {% set indoor = states('sensor.svotc_src_indoor') | float(none) %}
#           {% set target = states('sensor.svotc_dynamic_target_temperature') | float(none) %}
#           {% set activate_below = states('input_number.svotc_comfort_guard_activate_below_c') | float(1.0) %}
#           {% set deactivate_above = states('input_number.svotc_comfort_guard_deactivate_above_c') | float(0.4) %}
#           {% set was_on = is_state('binary_sensor.svotc_comfort_guard_active','on') %}
#           {% if indoor is not number or target is not number %}
#             {{ was_on }}
#           {% else %}
#             {% set activate_threshold = target - activate_below %}
#             {% set deactivate_threshold = target - deactivate_above %}
#             {% if was_on %}
#               {{ indoor < deactivate_threshold }}
#             {% else %}
#               {{ indoor < activate_threshold }}
#             {% endif %}
#           {% endif %}

#       #########################################################################
#       # 6b. Inputs healthy (CORE) - does NOT depend on price
#       #########################################################################
#       - name: "SVOTC Inputs healthy"
#         unique_id: svotc_inputs_healthy
#         state: >
#           {{ states('sensor.svotc_src_indoor') not in ['unknown','unavailable','none','']
#              and states('sensor.svotc_src_outdoor') not in ['unknown','unavailable','none',''] }}

#       #########################################################################
#       # 6c. Price available (diagnostic)
#       #########################################################################
#       - name: "SVOTC Price available"
#         unique_id: svotc_price_available
#         state: >
#           {{ states('sensor.svotc_src_current_price') not in ['unknown','unavailable','none',''] }}

# ###############################################################################
# # 7. Automations (State machines & Control loops)
# #    - 7.1 Price dwell (raw → stable with hysteresis)
# #    - 7.2 Brake phase state machine (idle/ramping_up/holding/ramping_down)
# #    - 7.3 Engine (requested → ramp-limited applied offset)
# ###############################################################################

#   ###########################################################################
#   # 7.1 Price dwell (raw -> stable)  [NON-NEGOTIABLE layer]
#   ###########################################################################
# automation:
#   - alias: "SVOTC Price dwell"
#     id: svotc_price_dwell
#     mode: single
#     trigger:
#       - platform: time_pattern
#         minutes: "/1"
#       - platform: state
#         entity_id: sensor.svotc_raw_price_state

#     action:
#       - variables:
#           raw: "{{ states('sensor.svotc_raw_price_state') }}"
#           stable: "{{ states('input_text.svotc_last_price_state') }}"
#           pending: "{{ states('input_text.svotc_pending_price_state') }}"

#       # If raw changed -> update pending and timestamp (start dwell)
#       - choose:
#           - conditions: "{{ raw != pending }}"
#             sequence:
#               - service: input_text.set_value
#                 target: { entity_id: input_text.svotc_pending_price_state }
#                 data: { value: "{{ raw }}" }
#               - service: input_datetime.set_datetime
#                 target: { entity_id: input_datetime.svotc_last_price_state_changed }
#                 data: { datetime: "{{ now() }}" }

#       # Calculate elapsed minutes since pending started
#       - variables:
#           ts: "{{ as_timestamp(states('input_datetime.svotc_last_price_state_changed'), default=none) }}"
#           elapsed_min: >
#             {% if ts is number %}
#               {{ (as_timestamp(now()) - ts) / 60 }}
#             {% else %}
#               999
#             {% endif %}
#           dwell_needed_min: >
#             {% if stable == 'cheap' and pending == 'neutral' %}
#               {{ states('input_number.svotc_price_dwell_cheap_to_neutral_min') | float(0) }}
#             {% elif stable == 'neutral' and pending == 'brake' %}
#               {{ states('input_number.svotc_price_dwell_neutral_to_brake_min') | float(0) }}
#             {% elif stable == 'brake' and pending == 'neutral' %}
#               {{ states('input_number.svotc_price_dwell_brake_to_neutral_min') | float(0) }}
#             {% elif stable == 'neutral' and pending == 'cheap' %}
#               {{ states('input_number.svotc_price_dwell_neutral_to_cheap_min') | float(0) }}
#             {% else %}
#               0
#             {% endif %}

#       # Accept pending as stable only after dwell time
#       - choose:
#           - conditions: >
#               {{ pending != stable and elapsed_min | float(0) >= dwell_needed_min | float(0) }}
#             sequence:
#               - service: input_text.set_value
#                 target: { entity_id: input_text.svotc_last_price_state }
#                 data: { value: "{{ pending }}" }

#   ###########################################################################
#   # 7.2 Brake phase controller (phase memory; do not spam writes)
#   ###########################################################################
#   - alias: "SVOTC Brake phase controller"
#     id: svotc_brake_phase_controller
#     mode: single
#     trigger:
#       - platform: time_pattern
#         minutes: "/1"
#       - platform: state
#         entity_id:
#           - input_text.svotc_last_price_state
#           - input_text.svotc_brake_phase

#     action:
#       - variables:
#           price_state: "{{ states('input_text.svotc_last_price_state') }}"
#           phase: "{{ states('input_text.svotc_brake_phase') }}"
#           phase_ts: "{{ as_timestamp(states('input_datetime.svotc_brake_phase_changed'), default=none) }}"
#           elapsed_min: >
#             {% if phase_ts is number %} {{ (as_timestamp(now()) - phase_ts) / 60 }} {% else %} 999 {% endif %}
#           rampup: "{{ states('input_number.svotc_brake_rampup_duration_min') | float(30) }}"
#           hold: "{{ states('input_number.svotc_brake_hold_duration_min') | float(60) }}"
#           rampdown: "{{ states('input_number.svotc_brake_rampdown_duration_min') | float(45) }}"

#       # If not braking -> force idle (only if needed)
#       - choose:
#           - conditions: "{{ price_state != 'brake' and phase != 'idle' }}"
#             sequence:
#               - service: input_text.set_value
#                 target: { entity_id: input_text.svotc_brake_phase }
#                 data: { value: "idle" }
#               - service: input_datetime.set_datetime
#                 target: { entity_id: input_datetime.svotc_brake_phase_changed }
#                 data: { datetime: "{{ now() }}" }
#               - stop: true

#       # If braking and currently idle -> start ramping_up (only if needed)
#       - choose:
#           - conditions: "{{ price_state == 'brake' and phase == 'idle' }}"
#             sequence:
#               - service: input_text.set_value
#                 target: { entity_id: input_text.svotc_brake_phase }
#                 data: { value: "ramping_up" }
#               - service: input_datetime.set_datetime
#                 target: { entity_id: input_datetime.svotc_brake_phase_changed }
#                 data: { datetime: "{{ now() }}" }
#               - stop: true

#       # Phase transitions based on elapsed time
#       - choose:
#           - conditions: "{{ phase == 'ramping_up' and elapsed_min >= rampup }}"
#             sequence:
#               - service: input_text.set_value
#                 target: { entity_id: input_text.svotc_brake_phase }
#                 data: { value: "holding" }
#               - service: input_datetime.set_datetime
#                 target: { entity_id: input_datetime.svotc_brake_phase_changed }
#                 data: { datetime: "{{ now() }}" }

#           - conditions: "{{ phase == 'holding' and elapsed_min >= hold }}"
#             sequence:
#               - service: input_text.set_value
#                 target: { entity_id: input_text.svotc_brake_phase }
#                 data: { value: "ramping_down" }
#               - service: input_datetime.set_datetime
#                 target: { entity_id: input_datetime.svotc_brake_phase_changed }
#                 data: { datetime: "{{ now() }}" }

#           - conditions: "{{ phase == 'ramping_down' and elapsed_min >= rampdown }}"
#             sequence:
#               - service: input_text.set_value
#                 target: { entity_id: input_text.svotc_brake_phase }
#                 data: { value: "idle" }
#               - service: input_datetime.set_datetime
#                 target: { entity_id: input_datetime.svotc_brake_phase_changed }
#                 data: { datetime: "{{ now() }}" }

#   ###########################################################################
#   # 7.3 SVOTC Engine (Control loop: requested → ramp-limited applied)
#   #     - Calculates comfort_term (negative = more heat when guard active)
#   #     - Calculates price_term (positive = less heat during expensive)
#   #     - Applies rate limiting (max_delta_per_step_c)
#   #     - FREEZE mode when inputs unhealthy (no vertical jumps)
#   ###########################################################################
#   - alias: "SVOTC Engine"
#     id: svotc_engine
#     mode: single
#     trigger:
#       - platform: time_pattern
#         minutes: "/1"
#       - platform: state
#         entity_id:
#           - input_select.svotc_mode
#           - input_text.svotc_last_price_state
#           - input_text.svotc_brake_phase
#           - sensor.svotc_prebrake_strength
#           - binary_sensor.svotc_comfort_guard_active
#           - input_number.svotc_brake_hold_offset_c
#           - input_number.svotc_heat_aggressiveness
#           - input_number.svotc_max_delta_per_step_c

#     variables:
#       mode: "{{ states('input_select.svotc_mode') }}"
#       healthy: "{{ is_state('binary_sensor.svotc_inputs_healthy','on') }}"
#       guard: "{{ is_state('binary_sensor.svotc_comfort_guard_active','on') }}"
#       price_state: "{{ states('input_text.svotc_last_price_state') }}"
#       phase: "{{ states('input_text.svotc_brake_phase') }}"
#       pre: "{{ states('sensor.svotc_prebrake_strength') | float(0) }}"
#       hold_offset: "{{ states('input_number.svotc_brake_hold_offset_c') | float(0) }}"
#       heat_aggr: "{{ states('input_number.svotc_heat_aggressiveness') | int(0) }}"
#       max_delta: "{{ states('input_number.svotc_max_delta_per_step_c') | float(0.2) }}"

#       # Helper bounds (avoid set_value failures)
#       req_min: "{{ state_attr('input_number.svotc_requested_offset_c','min') | float(-10) }}"
#       req_max: "{{ state_attr('input_number.svotc_requested_offset_c','max') | float(10) }}"
#       app_min: "{{ state_attr('input_number.svotc_applied_offset_c','min') | float(-10) }}"
#       app_max: "{{ state_attr('input_number.svotc_applied_offset_c','max') | float(10) }}"

#       # --- Comfort term (negative offset -> more heating) ---
#       comfort_term: >
#         {% if mode in ['Off','PassThrough'] %}
#           0
#         {% elif guard %}
#           {{ -(heat_aggr * 0.4) }}   {# heat=5 -> -2.0°C #}
#         {% else %}
#           0
#         {% endif %}

#       # --- Price term (positive offset -> less heating) ---
#       price_term: >
#         {% if mode != 'Smart' %}
#           0
#         {% elif guard %}
#           0
#         {% else %}
#           {{ hold_offset * pre }}
#         {% endif %}

#       requested_raw: "{{ (comfort_term + price_term) | float(0) }}"
#       requested: "{{ requested_raw | clamp(req_min, req_max) | round(2) }}"

#       prev_applied: "{{ states('input_number.svotc_applied_offset_c') | float(requested) }}"
#       delta: "{{ requested - prev_applied }}"

#       next_applied_raw: >
#         {% if delta > max_delta %}
#           {{ prev_applied + max_delta }}
#         {% elif delta < -max_delta %}
#           {{ prev_applied - max_delta }}
#         {% else %}
#           {{ requested }}
#         {% endif %}
#       next_applied: "{{ next_applied_raw | clamp(app_min, app_max) | round(2) }}"

#       reason: >
#         {% if mode == 'Off' %}
#           OFF
#         {% elif not healthy %}
#           MISSING_INPUTS
#         {% elif mode == 'PassThrough' %}
#           PASS_THROUGH
#         {% elif mode == 'ComfortOnly' %}
#           COMFORT_ONLY
#         {% elif guard and pre > 0 %}
#           MCP_BLOCKS_BRAKE
#         {% elif guard %}
#           COMFORT_GUARD
#         {% elif pre > 0 %}
#           PRICE_BRAKE
#         {% else %}
#           NEUTRAL
#         {% endif %}

#     action:
#       # If missing inputs in Smart/ComfortOnly: set requested=0 but FREEZE applied (no jumps)
#       - choose:
#           - conditions: "{{ not healthy and mode in ['Smart','ComfortOnly'] }}"
#             sequence:
#               - service: input_number.set_value
#                 target: { entity_id: input_number.svotc_requested_offset_c }
#                 data: { value: 0 }
#               # DO NOT touch applied here (freeze)
#               - service: input_text.set_value
#                 target: { entity_id: input_text.svotc_reason_code }
#                 data: { value: "MISSING_INPUTS_FREEZE" }
#               - stop: true

#       - service: input_number.set_value
#         target: { entity_id: input_number.svotc_requested_offset_c }
#         data: { value: "{{ requested }}" }

#       - service: input_number.set_value
#         target: { entity_id: input_number.svotc_applied_offset_c }
#         data: { value: "{{ next_applied }}" }

#       - service: input_text.set_value
#         target: { entity_id: input_text.svotc_reason_code }
#         data: { value: "{{ reason }}" }

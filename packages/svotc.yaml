###############################################################################
# SVOTC package (YAML engine)                                                 #
# - Logic: stable + explainable                                               #
# - Uses Nordpool Tibber attributes: current_price, raw_today, raw_tomorrow   #
###############################################################################

input_select:
  svotc_mode:
    name: "SVOTC Mode"
    options:
      - "Off"
      - "Smart"
      - "Vacation"
      - "PassThrough"
      - "ComfortOnly"

input_number:
  svotc_brake_aggressiveness:
    name: "SVOTC Brake aggressiveness"
    min: 0
    max: 5
    step: 1
    mode: slider

  svotc_heat_aggressiveness:
    name: "SVOTC Heat aggressiveness"
    min: 0
    max: 5
    step: 1
    mode: slider

  svotc_comfort_temperature:
    name: "SVOTC Comfort temperature"
    min: 15
    max: 25
    step: 0.1
    mode: box

  svotc_vacation_temperature:
    name: "SVOTC Vacation temperature"
    min: 10
    max: 25
    step: 0.1
    mode: box

  svotc_requested_offset_c:
    name: "SVOTC Requested offset (C)"
    min: -10
    max: 10
    step: 0.1
    mode: box

  svotc_applied_offset_c:
    name: "SVOTC Applied offset (C)"
    min: -10
    max: 10
    step: 0.1
    mode: box

  svotc_max_delta_per_step_c:
    name: "SVOTC Max delta per step (C)"
    min: 0.1
    max: 5
    step: 0.1
    mode: box

  svotc_comfort_guard_deadband_c:
    name: "SVOTC Comfort guard deadband (C)"
    min: 0.0
    max: 2.0
    step: 0.1
    mode: box

  svotc_price_dwell_minutes:
    name: "SVOTC Price dwell (min)"
    min: 0
    max: 120
    step: 1
    mode: box

  svotc_brake_hold_offset_c:
    name: "SVOTC Brake hold offset (C)"
    min: 0
    max: 10
    step: 0.1
    mode: box

input_text:
  svotc_reason_code:
    name: "SVOTC Reason code"
  svotc_last_price_state:
    name: "SVOTC Last price state"
  svotc_pending_price_state:
    name: "SVOTC Pending price state"
  svotc_brake_phase:
    name: "SVOTC Brake phase"

input_datetime:
  svotc_last_price_state_changed:
    name: "SVOTC Last price state changed"
    has_date: true
    has_time: true
  svotc_brake_phase_changed:
    name: "SVOTC Brake phase changed"
    has_date: true
    has_time: true

template:
  - sensor:
      - name: "SVOTC Src Indoor"
        unique_id: svotc_src_indoor
        unit_of_measurement: "°C"
        device_class: temperature
        state_class: measurement
        state: "{{ states('sensor.inomhusmedel') | float(none) }}"
        availability: "{{ states('sensor.inomhusmedel') | is_number }}"

      - name: "SVOTC Src Outdoor"
        unique_id: svotc_src_outdoor
        unit_of_measurement: "°C"
        device_class: temperature
        state_class: measurement
        state: "{{ states('sensor.temperatur_nu') | float(none) }}"
        availability: "{{ states('sensor.temperatur_nu') | is_number }}"

      - name: "SVOTC Src Current Price"
        unique_id: svotc_src_current_price
        unit_of_measurement: "SEK/kWh"
        state: >
          {% set p = state_attr('sensor.nordpool_tibber', 'current_price') %}
          {{ p | round(3) if p is number else this.state | float(0) }}
        availability: "{{ state_attr('sensor.nordpool_tibber', 'current_price') is number }}"

      - name: "SVOTC Dynamic target temperature"
        unique_id: svotc_dynamic_target_temperature
        unit_of_measurement: "°C"
        device_class: temperature
        state: >
          {% set mode = states('input_select.svotc_mode') %}
          {% if mode == 'Vacation' %}
            {{ states('input_number.svotc_vacation_temperature') | float(20) }}
          {% else %}
            {{ states('input_number.svotc_comfort_temperature') | float(21) }}
          {% endif %}

      - name: "SVOTC P30"
        unique_id: svotc_p30
        state: &percentile_logic >
          {% set today = state_attr('sensor.nordpool_tibber', 'raw_today') | default([], true) %}
          {% set tomorrow = state_attr('sensor.nordpool_tibber', 'raw_tomorrow') | default([], true) %}
          {% set combined = today + tomorrow %}
          {% set prices = combined | map(attribute='value') | select('number') | list %}
          
          {% if prices | length >= 10 %}
            {% set s = prices | sort %}
            {# Bestäm vilken percentil som ska användas baserat på namnet #}
            {% set pct = 0.30 if 'P30' in this.name else (0.70 if 'P70' in this.name else 0.80) %}
            {# Beräkna index och använd filter för att hålla det inom listans gränser #}
            {% set idx = ((s | length) * pct) | int %}
            {% set safe_idx = ([0, idx, (s | length - 1)] | sort)[1] %}
            {{ s[safe_idx] | round(3) }}
          {% else %}
            {{ states(this.entity_id) if states(this.entity_id) | is_number else 'unknown' }}
          {% endif %}

      - name: "SVOTC P70"
        unique_id: svotc_p70
        state: *percentile_logic

      - name: "SVOTC P80"
        unique_id: svotc_p80
        state: *percentile_logic

      - name: "SVOTC Current price"
        unique_id: svotc_current_price
        unit_of_measurement: "SEK/kWh"
        state: "{{ states('sensor.svotc_src_current_price') | float(none) }}"

      - name: "SVOTC Raw price state"
        unique_id: svotc_raw_price_state
        state: >
          {% set mode = states('input_select.svotc_mode') %}
          {% if mode in ['Off', 'PassThrough', 'ComfortOnly'] %} off
          {% else %}
            {% set p = states('sensor.svotc_src_current_price') | float(none) %}
            {% set p30 = states('sensor.svotc_p30') | float(none) %}
            {% set p80 = states('sensor.svotc_p80') | float(none) %}
            {% if p is number and p80 is number and p > p80 %} brake
            {% elif p is number and p30 is number and p < p30 %} cheap
            {% else %} neutral {% endif %}
          {% endif %}

      - name: "SVOTC Virtual outdoor temperature"
        unique_id: svotc_virtual_outdoor_temperature
        unit_of_measurement: "°C"
        device_class: temperature
        state: >
          {% set out = states('sensor.svotc_src_outdoor') | float(none) %}
          {% set off = states('input_number.svotc_applied_offset_c') | float(0) %}
          {% if out is number %}
            {# Clamp förhindrar att vi skickar värden utanför pumpens normala arbetsområde #}
            {{ (out + off) | clamp(-35, 35) | round(2) }}
          {% else %}
            {{ this.state }}
          {% endif %}

      - name: "SVOTC Next peak price"
        unique_id: svotc_next_peak_price
        unit_of_measurement: "SEK/kWh"
        state: >
          {% set today = state_attr('sensor.nordpool_tibber', 'raw_today') | default([], true) %}
          {% set tomorrow = state_attr('sensor.nordpool_tibber', 'raw_tomorrow') | default([], true) %}
          {% set combined = today + tomorrow %}
          {% set window = states('sensor.svotc_prebrake_window_min') | float(0) %}
          {% set horizon_m = (window + 30) | clamp(15, 180) %}
          {% set now_ts = as_timestamp(now()) %}
          {% set end_ts = now_ts + (horizon_m * 60) %}
          {% set ns = namespace(vals=[]) %}
          {% for it in combined %}
            {% set v = it.value | float(none) %}
            {% set ts = as_timestamp(it.start) if it.start is defined else none %}
            {% if v is number and ts is number and ts >= (now_ts - 3600) and ts <= end_ts %}
              {% set ns.vals = ns.vals + [v] %}
            {% endif %}
          {% endfor %}
          {{ (ns.vals | max | round(3)) if ns.vals | length > 0 else states('sensor.svotc_src_current_price') }}

      - name: "SVOTC Minutes to next peak"
        unique_id: svotc_minutes_to_next_peak
        unit_of_measurement: "min"
        state: >
          {% set today = state_attr('sensor.nordpool_tibber', 'raw_today') | default([], true) %}
          {% set tomorrow = state_attr('sensor.nordpool_tibber', 'raw_tomorrow') | default([], true) %}
          {% set combined = today + tomorrow %}
          {% set peak = states('sensor.svotc_next_peak_price') | float(none) %}
          {% if peak is number %}
            {% set ns = namespace(best=none) %}
            {% for it in combined %}
              {% set v = it.value | float(none) %}
              {% set ts = as_timestamp(it.start) if it.start is defined else none %}
              {% if v is number and ts is number and (v - peak)|abs < 0.001 and ts >= as_timestamp(now()) %}
                {% set mins = (ts - as_timestamp(now())) / 60 %}
                {% if ns.best is none or mins < ns.best %}{% set ns.best = mins %}{% endif %}
              {% endif %}
            {% endfor %}
            {{ [ns.best | round(1), 0] | max if ns.best is not none else 0 }}
          {% else %} 0 {% endif %}

      - name: "SVOTC Status"
        unique_id: svotc_status
        state: >
          {% set mode = states('input_select.svotc_mode') %}
          {% if mode == 'Off' %} Off
          {% else %}
            {% set r = states('input_text.svotc_reason_code') %}
            {% set mapper = {
              'OFF': 'Off',
              'PASS_THROUGH': 'Pass-through (no control)',
              'COMFORT_ONLY': 'Comfort only',
              'MISSING_INDOOR': 'Missing indoor',
              'MCP': 'MCP (comfort)',
              'PRICE_LIMITING_COMFORT': 'Comfort guard',
              'PRICE_BRAKE': 'Braking (price)',
              'COMFORT': 'Comfort'
            } %}
            {{ mapper.get(r, r if r not in ['unknown','unavailable',''] else 'Initialising') }}
          {% endif %}

      - name: "SVOTC Prebrake window (min)"
        unique_id: svotc_prebrake_window_min
        unit_of_measurement: "min"
        state: >
          {% set a = states('input_number.svotc_brake_aggressiveness') | int(0) %}
          {% set mapper = {0:0, 1:3, 2:10, 3:20, 4:35, 5:60} %}
          {{ mapper.get(a, 0) }}

      - name: "SVOTC Prebrake strength"
        unique_id: svotc_prebrake_strength
        state: >
          {% set window = states('sensor.svotc_prebrake_window_min') | float(0) %}
          {% set mins = states('sensor.svotc_minutes_to_next_peak') | float(999) %}
          {% set peak = states('sensor.svotc_next_peak_price') | float(0) %}
          {% set p80 = states('sensor.svotc_p80') | float(0) %}
          {% if window > 0 and peak > p80 and mins <= window %}
            {{ ((window - mins) / window) | round(3) | clamp(0, 1) }}
          {% else %} 0 {% endif %}

  - binary_sensor:
      - name: "SVOTC Comfort guard active"
        unique_id: svotc_comfort_guard_active
        state: >
          {% set indoor = states('sensor.svotc_src_indoor') | float(none) %}
          {% set target = states('sensor.svotc_dynamic_target_temperature') | float(none) %}
          {% set db = states('input_number.svotc_comfort_guard_deadband_c') | float(1) %}
          {{ indoor < (target - db) if indoor is number and target is number else false }}

      - name: "SVOTC Price available"
        unique_id: svotc_price_available
        state: "{{ states('sensor.svotc_src_current_price') | is_number }}"

      - name: "SVOTC Brake active"
        unique_id: svotc_brake_active
        state: "{{ is_state('input_text.svotc_last_price_state','brake') }}"

automation:
  - alias: "SVOTC Price dwell"
    id: svotc_price_dwell
    trigger:
      - platform: time_pattern
        minutes: "/1"
      - platform: state
        entity_id: sensor.svotc_raw_price_state
    action:
      - variables:
          raw: "{{ states('sensor.svotc_raw_price_state') }}"
          stable: "{{ states('input_text.svotc_last_price_state') }}"
          pending: "{{ states('input_text.svotc_pending_price_state') }}"
          dwell: "{{ states('input_number.svotc_price_dwell_minutes') | int(30) }}"
          last_ch: "{{ states('input_datetime.svotc_last_price_state_changed') }}"
          diff: "{{ (as_timestamp(now()) - as_timestamp(last_ch)) / 60 if last_ch | as_datetime is not none else 999 }}"
      - choose:
          - conditions: "{{ raw == stable }}"
            sequence:
              - service: input_text.set_value
                target: { entity_id: input_text.svotc_pending_price_state }
                data: { value: "{{ stable }}" }
          - conditions: "{{ raw != stable and raw != pending }}"
            sequence:
              - service: input_text.set_value
                target: { entity_id: input_text.svotc_pending_price_state }
                data: { value: "{{ raw }}" }
              - service: input_datetime.set_datetime
                target: { entity_id: input_datetime.svotc_last_price_state_changed }
                data: { datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}" }
          - conditions: "{{ raw != stable and raw == pending and diff >= dwell }}"
            sequence:
              - service: input_text.set_value
                target: { entity_id: input_text.svotc_last_price_state }
                data: { value: "{{ raw }}" }
              - service: input_datetime.set_datetime
                target: { entity_id: input_datetime.svotc_last_price_state_changed }
                data: { datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}" }

  - alias: "SVOTC Brake phase manager"
    id: svotc_brake_phase_manager
    trigger:
      - platform: time_pattern
        minutes: "/1"
      - platform: state
        entity_id: 
          - input_text.svotc_last_price_state
          - binary_sensor.svotc_comfort_guard_active
          - input_select.svotc_mode
    action:
      - variables:
          mode: "{{ states('input_select.svotc_mode') }}"
          want_brake: >-
            {{ mode not in ['Off','PassThrough','ComfortOnly']
               and is_state('input_text.svotc_last_price_state','brake')
               and is_state('binary_sensor.svotc_comfort_guard_active','off') }}
          phase: "{{ states('input_text.svotc_brake_phase') }}"
      - choose:
          # If mode disables price control, force phase to idle.
          - conditions: "{{ mode in ['Off','PassThrough','ComfortOnly'] }}"
            sequence:
              - service: input_text.set_value
                target: { entity_id: input_text.svotc_brake_phase }
                data: { value: "idle" }

          - conditions: "{{ want_brake }}"
            sequence:
              - service: input_number.set_value
                target: { entity_id: input_number.svotc_brake_hold_offset_c }
                data: { value: "{{ (states('input_number.svotc_brake_aggressiveness')|float * 2.0) }}" }
              - if: "{{ phase not in ['ramping_up','holding'] }}"
                then:
                  - service: input_text.set_value
                    target: { entity_id: input_text.svotc_brake_phase }
                    data: { value: "ramping_up" }

          - conditions: "{{ not want_brake and phase in ['ramping_up','holding'] }}"
            sequence:
              - service: input_text.set_value
                target: { entity_id: input_text.svotc_brake_phase }
                data: { value: "ramping_down" }

  - alias: "SVOTC Engine"
    id: svotc_engine
    trigger:
      - platform: time_pattern
        minutes: "/1"
    action:
      - variables:
          mode: "{{ states('input_select.svotc_mode') }}"
          indoor: "{{ states('sensor.svotc_src_indoor') | float(none) }}"
          target: "{{ states('sensor.svotc_dynamic_target_temperature') | float(none) }}"
          brake_aggr: "{{ states('input_number.svotc_brake_aggressiveness') | float(0) }}"
          heat_aggr: "{{ states('input_number.svotc_heat_aggressiveness') | float(0) }}"
          prebrake: "{{ states('sensor.svotc_prebrake_strength') | float(0) }}"
          phase: "{{ states('input_text.svotc_brake_phase') }}"
          guard: "{{ is_state('binary_sensor.svotc_comfort_guard_active','on') }}"
          
          req: >
            {% if indoor is not number %} 0
            {% elif mode == 'Off' %} 0
            {% elif mode == 'PassThrough' %} 0
            {% else %}
              {% set err = target - indoor %}
              {% set comfort = (err * -1.0) if err|abs > 0.4 else 0 %}
              {% set comfort_clamped = comfort | clamp(-(heat_aggr*2), (brake_aggr*2)) %}

              {# ComfortOnly = no price term, ever #}
              {% if mode == 'ComfortOnly' %}
                {{ comfort_clamped | clamp(-10, 10) | round(2) }}
              {% else %}
                {% set price = (states('input_number.svotc_brake_hold_offset_c')|float * prebrake)
                               if (not guard and phase in ['ramping_up','holding']) else 0 %}
                {{ (comfort_clamped + price) | clamp(-10, 10) | round(2) }}
              {% endif %}
            {% endif %}
          
          applied_prev: "{{ states('input_number.svotc_applied_offset_c') | float(0) }}"
          max_d: "{{ states('input_number.svotc_max_delta_per_step_c') | float(0.5) }}"
          new_applied: "{{ (applied_prev + ([ -max_d, [ (req - applied_prev), max_d ] | min ] | max)) | round(2) }}"

      - service: input_number.set_value
        target: { entity_id: input_number.svotc_requested_offset_c }
        data: { value: "{{ req }}" }
      - service: input_number.set_value
        target: { entity_id: input_number.svotc_applied_offset_c }
        data: { value: "{{ new_applied }}" }

      - service: input_text.set_value
        target: { entity_id: input_text.svotc_reason_code }
        data:
          value: >
            {% if mode == 'Off' %} OFF
            {% elif mode == 'PassThrough' %} PASS_THROUGH
            {% elif mode == 'ComfortOnly' %} COMFORT_ONLY
            {% elif guard %} PRICE_LIMITING_COMFORT
            {% elif prebrake > 0 and phase in ['ramping_up','holding'] %} PRICE_BRAKE
            {% else %} COMFORT {% endif %}

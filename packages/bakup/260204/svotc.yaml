###############################################################################
# SVOTC package (YAML engine) - IMPROVED VERSION med HJÄLPTEXTER
# 
# FÖRBÄTTRINGAR:
# 1. Brake phase manager får time_pattern trigger
# 2. Komplett state machine för brake phases med timers
# 3. Hysteres i comfort guard (olika av/på-trösklar)
# 4. Validering av extrema sensorvärden + fail-safe
# 5. Separata dwell-tider per övergång
# 6. Logging/historia för alla viktiga värden
#
# EDIT HERE / SENSOR-MAPPNING:
#   Ändra dessa tre helpers för att ändra kod överallt:
#     - input_text.svotc_entity_indoor  = din inomhustemperatur-sensor
#     - input_text.svotc_entity_outdoor = din utomhustemperatur-sensor
#     - input_text.svotc_entity_price   = din elpris-sensor
#
# HÅRDKODADE VÄRDEN SOM KAN JUSTERAS:
#   Sök efter "TUNING:" i denna fil för att hitta alla ställen där du kan
#   justera värden. Alla viktiga hårdkodade värden är dokumenterade.
###############################################################################

###############################################################################
# 1 UI / Controls
###############################################################################

input_select:
  svotc_mode:
    name: "SVOTC Mode"
    options:
      - "Off"          # Systemet avstängt
      - "Smart"        # Full kontroll (pris + komfort)
      - "PassThrough"  # Ingen kontroll, bara övervakning
      - "ComfortOnly"  # Endast komfortstyrning, ingen prisbroms

input_number:
  # --- Tuning: aggressiveness ---
  svotc_brake_aggressiveness:
    name: "SVOTC Brake aggressiveness"
    min: 0
    max: 5
    step: 1
    mode: slider
    # HJÄLPTEXT: Styr hur kraftig bromsen är vid höga priser
    # 0 = ingen broms, 1-2 = mild, 3-4 = medel, 5 = aggressiv

  svotc_heat_aggressiveness:
    name: "SVOTC Heat aggressiveness"
    min: 0
    max: 5
    step: 1
    mode: slider
    # HJÄLPTEXT: Styr hur mycket extra värme vid låga priser
    # 0 = ingen extra värme, 1-2 = mild, 3-4 = medel, 5 = aggressiv

  # --- Temperature setpoints ---
  svotc_comfort_temperature:
    name: "SVOTC Comfort temperature"
    min: 15
    max: 25
    step: 0.1
    mode: box
    # HJÄLPTEXT: Din önskade inomhustemperatur
    # Typiskt: 20-22°C för vardagsrum, 18-19°C för sovrum

  # --- Offsets / actuation ---
  svotc_requested_offset_c:
    name: "SVOTC Requested offset (C)"
    min: -10
    max: 10
    step: 0.1
    mode: box
    # HJÄLPTEXT: Det offset systemet VILL ha (före rate limiting)
    # Negativt = lura pumpen att värma mer, Positivt = värma mindre

  svotc_applied_offset_c:
    name: "SVOTC Applied offset (C)"
    min: -10
    max: 10
    step: 0.1
    mode: box
    # HJÄLPTEXT: Det offset som FAKTISKT används (efter rate limiting)
    # Detta är värdet som läggs till din utomhustemperatur

  svotc_max_delta_per_step_c:
    name: "SVOTC Max delta per step (C)"
    min: 0.01
    max: 5
    step: 0.01
    mode: box
    # HJÄLPTEXT: Max förändring av offset per minut
    # 0.5 = standard (säkert), 1.0 = snabbare, 0.2 = försiktigare
    # Skyddar mot abrupt offset-hopp som kan förvirra värmepumpen

  # --- Comfort guard / stability (NU MED HYSTERES) ---
  svotc_comfort_guard_activate_below_c:
    name: "SVOTC Comfort guard activate (below target)"
    min: 0.0
    max: 3.0
    step: 0.1
    mode: box
    initial: 0.8
    # HJÄLPTEXT: Aktivera comfort guard när temp < (target - detta värde)
    # Exempel: Target=21°C, värde=0.8 → aktiveras vid <20.2°C
    # Högre värde = tidigare aktivering = mer försiktig

  svotc_comfort_guard_deactivate_above_c:
    name: "SVOTC Comfort guard deactivate (above target)"
    min: 0.0
    max: 3.0
    step: 0.1
    mode: box
    initial: 0.4
    # HJÄLPTEXT: Deaktivera guard när temp > (target - detta värde)
    # Exempel: Target=21°C, värde=0.4 → deaktiveras vid >20.6°C
    # Hysteres = skillnad mellan activate och deactivate (här 0.4°C)
    # Större hysteres = stabilare, mindre oscillation

  # --- FÖRBÄTTRING 5: Separata dwell-tider ---
  svotc_price_dwell_cheap_to_neutral_min:
    name: "SVOTC Dwell: cheap→neutral (min)"
    min: 5
    max: 120
    step: 5
    mode: box
    initial: 20
    # HJÄLPTEXT: Vänta så här länge innan priset bekräftas som "neutral" från "cheap"
    # 20 min = standard (balanserat)
    # Lägre = snabbare reaktion men risk för flapping
    # Högre = stabilare men kan missa korta perioder

  svotc_price_dwell_neutral_to_brake_min:
    name: "SVOTC Dwell: neutral→brake (min)"
    min: 5
    max: 120
    step: 5
    mode: box
    initial: 30
    # HJÄLPTEXT: Vänta innan priset bekräftas som "brake" (dyr)
    # 30 min = standard (försiktig med att bromsa)
    # Högre = undvik onödig bromsning vid korta pristoppar
    # Lägre = reagera snabbare på höga priser

  svotc_price_dwell_brake_to_neutral_min:
    name: "SVOTC Dwell: brake→neutral (min)"
    min: 5
    max: 120
    step: 5
    mode: box
    initial: 15
    # HJÄLPTEXT: Vänta innan pristoppen bekräftas som över
    # 15 min = standard (relativt snabb återgång)
    # Lägre = börja värma snabbare efter topp
    # Högre = vänta längre för att vara säker

  svotc_price_dwell_neutral_to_cheap_min:
    name: "SVOTC Dwell: neutral→cheap (min)"
    min: 5
    max: 120
    step: 5
    mode: box
    initial: 10
    # HJÄLPTEXT: Vänta innan priset bekräftas som "cheap" (billigt)
    # 10 min = standard (snabb reaktion)
    # Lägre = utnyttja billiga timmar snabbare
    # Högre = mer konservativ, undvik felaktivering

  # --- FÖRBÄTTRING 2: Brake phase timers ---
  svotc_brake_rampup_duration_min:
    name: "SVOTC Brake ramp-up duration (min)"
    min: 5
    max: 120
    step: 5
    mode: box
    initial: 30
    # HJÄLPTEXT: Hur länge "ramping_up"-fasen pågår (gradvis ökning av offset)
    # 30 min = standard (mjuk övergång)
    # Kortare = snabbare bromseffekt men mer abrupt
    # Längre = mjukare men långsammare reaktion

  svotc_brake_hold_duration_min:
    name: "SVOTC Brake hold duration (min)"
    min: 10
    max: 300
    step: 10
    mode: box
    initial: 60
    # HJÄLPTEXT: Hur länge "holding"-fasen pågår (full broms aktiv)
    # 60 min = standard
    # Kan sättas längre om pristoppar varar länge
    # Systemet kan hoppa ur hold tidigt om priset sjunker

  svotc_brake_rampdown_duration_min:
    name: "SVOTC Brake ramp-down duration (min)"
    min: 5
    max: 120
    step: 5
    mode: box
    initial: 45
    # HJÄLPTEXT: Hur länge "ramping_down"-fasen pågår (gradvis minskning av offset)
    # 45 min = standard (återgång till normalläge)
    # Längre = mjukare återgång, mindre stressande för värmepump
    # Kortare = snabbare återgång till normal drift

  # --- Brake phase management ---
  svotc_brake_hold_offset_c:
    name: "SVOTC Brake hold offset (C)"
    min: 0
    max: 10
    step: 0.1
    mode: box
    # HJÄLPTEXT: Automatiskt beräknat baserat på brake_aggressiveness
    # Värde = aggressiveness × 2.0
    # Manuell justering möjlig om automatiken inte passar

  # --- FÖRBÄTTRING 6: Statistik ---
  svotc_total_offset_hours_today:
    name: "SVOTC Total offset hours today"
    min: 0
    max: 24
    step: 0.01
    mode: box
    # HJÄLPTEXT: Räknare för hur många timmar offset > 0.5°C använts idag
    # Nollställs automatiskt vid midnatt
    # Används för att övervaka offset-användning

  svotc_max_offset_hours_per_day:
    name: "SVOTC Max offset hours per day"
    min: 0
    max: 24
    step: 1
    mode: box
    initial: 18
    # HJÄLPTEXT: Max antal timmar per dag som stort offset är tillåtet
    # 18h = standard (75% av dygnet)
    # Lägre = skydda värmepumpen mer
    # Kan användas för framtida begränsningar

input_text:
  # --- EDIT HERE: entity mapping ---
  svotc_entity_indoor:
    name: "SVOTC Entity: Indoor temperature"
    initial: "sensor.inomhusmedel"
    # HJÄLPTEXT: Ändra till din inomhustemperatur-sensor
    # Måste vara en sensor som rapporterar i °C
    # Tips: Använd ett medelvärde av flera sensorer för stabilitet
    
  svotc_entity_outdoor:
    name: "SVOTC Entity: Outdoor temperature"
    initial: "sensor.temperatur_nu"
    # HJÄLPTEXT: Ändra till din utomhustemperatur-sensor
    # Måste vara en sensor som rapporterar i °C
    # Tips: Använd samma sensor som din värmepump läser

  svotc_entity_price:
    name: "SVOTC Entity: Price sensor"
    initial: "sensor.nordpool_tibber"
    # HJÄLPTEXT: Ändra till din elpris-sensor
    # Måste ha attributes: current_price, raw_today, raw_tomorrow
    # Kompatibel med Nordpool/Tibber HACS-integrationen

#   svotc_entity_price_today:
#     name: "SVOTC Entity: Price today (official Nordpool)"
#     initial: "sensor.today_price"

#   svotc_entity_price_tomorrow:
#     name: "SVOTC Entity: Price tomorrow (official Nordpool)"
#     initial: "sensor.tomorrow_price"

  # --- FÖRBÄTTRING 6: Notifierare konfigurerbar ---
  svotc_notifier:
    name: "SVOTC Notifier service"
    initial: "notify.notify"
    # HJÄLPTEXT: Ändra till din notifikationstjänst
    # Exempel: notify.mobile_app_din_telefon
    #          notify.telegram
    #          notify.email
    
  # --- Diagnostics / state ---
  svotc_reason_code:
    name: "SVOTC Reason code"
    # HJÄLPTEXT: Visar varför systemet agerar som det gör
    # Värden: OFF, PASS_THROUGH, COMFORT_ONLY, MCP, PRICE_BRAKE, etc.
    
  svotc_last_price_state:
    name: "SVOTC Last price state"
    # HJÄLPTEXT: Senast bekräftade prisstatus (efter dwell)
    # Värden: off, cheap, neutral, brake
    
  svotc_pending_price_state:
    name: "SVOTC Pending price state"
    # HJÄLPTEXT: Prisstatus som väntar på bekräftelse
    # Värden: off, cheap, neutral, brake
    
  svotc_brake_phase:
    name: "SVOTC Brake phase"
    initial: "idle"
    # HJÄLPTEXT: Aktuell fas i bromsprocessen
    # Värden: idle, ramping_up, holding, ramping_down

input_datetime:
  svotc_last_price_state_changed:
    name: "SVOTC Last price state changed"
    has_date: true
    has_time: true
    # HJÄLPTEXT: Tidsstämpel för senaste prisstatusändring
    # Används för dwell-tidräkning

  svotc_brake_phase_changed:
    name: "SVOTC Brake phase changed"
    has_date: true
    has_time: true
    # HJÄLPTEXT: Tidsstämpel för senaste fasändring
    # Används för att beräkna progress och fasövergångar

  svotc_offset_hours_reset:
    name: "SVOTC Offset hours last reset"
    has_date: true
    has_time: true
    # HJÄLPTEXT: Tidsstämpel för senaste nollställning av offset-räknare
    # Uppdateras vid midnatt

input_boolean:
  svotc_missing_inputs_alerted:
    name: "SVOTC Missing inputs alerted"
    # HJÄLPTEXT: Latch för att undvika spam-notifikationer
    # Återställs när alla sensorer fungerar igen

  # Fail-safe mode ---
  svotc_fail_safe_active:
    name: "SVOTC Fail-safe mode active"
    # HJÄLPTEXT: Indikerar att systemet är i säkert läge
    # Aktiveras om sensorer ger ogiltiga värden i >5 min
    # Offset nollställs automatiskt

###############################################################################
# 2 Template sensors
###############################################################################

template:
  - sensor:

      #########################################################################
      # 2.1 Source sensors (FÖRBÄTTRING 4: validering + fail-safe)
      #########################################################################

      - name: "SVOTC Src Indoor"
        unique_id: svotc_src_indoor
        unit_of_measurement: "°C"
        device_class: temperature
        state_class: measurement
        state: >
          {% set ent = states('input_text.svotc_entity_indoor') %}
          {% set ent = ent if ent not in ['unknown','unavailable',''] else 'sensor.inomhusmedel' %}
          {% set val = states(ent) | float(none) %}
          {# TUNING: Rimliga inomhusvärden 10-35°C #}
          {# Ändra gränser här om du har extrema förhållanden: #}
          {# - Vinterbostad i fjällen: kanske 5-30°C #}
          {# - Varmt klimat: kanske 15-40°C #}
          {% if val is number and val >= 10 and val <= 35 %}
            {{ val | round(2) }}
          {% else %}
            {{ this.state if this.state | is_number else none }}
          {% endif %}
        availability: >
          {% set ent = states('input_text.svotc_entity_indoor') %}
          {% set ent = ent if ent not in ['unknown','unavailable',''] else 'sensor.inomhusmedel' %}
          {% set val = states(ent) | float(none) %}
          {{ val is number and val >= 10 and val <= 35 }}

      - name: "SVOTC Src Outdoor"
        unique_id: svotc_src_outdoor
        unit_of_measurement: "°C"
        device_class: temperature
        state_class: measurement
        state: >
          {% set ent = states('input_text.svotc_entity_outdoor') %}
          {% set ent = ent if ent not in ['unknown','unavailable',''] else 'sensor.temperatur_nu' %}
          {% set val = states(ent) | float(none) %}
          {# TUNING: Rimliga utomhusvärden -40 till +45°C #}
          {# Ändra gränser här baserat på ditt klimat: #}
          {# - Norra Sverige: kanske -50 till +35°C #}
          {# - Södra Europa: kanske -10 till +50°C #}
          {% if val is number and val >= -40 and val <= 45 %}
            {{ val | round(2) }}
          {% else %}
            {{ this.state if this.state | is_number else none }}
          {% endif %}
        availability: >
          {% set ent = states('input_text.svotc_entity_outdoor') %}
          {% set ent = ent if ent not in ['unknown','unavailable',''] else 'sensor.temperatur_nu' %}
          {% set val = states(ent) | float(none) %}
          {{ val is number and val >= -40 and val <= 45 }}

      - name: "SVOTC Src Current Price"
        unique_id: svotc_src_current_price
        unit_of_measurement: "SEK/kWh"
        state: >
          {% set ent = states('input_text.svotc_entity_price') %}
          {% set ent = ent if ent not in ['unknown','unavailable',''] else 'sensor.nordpool_tibber' %}
          {% set p = state_attr(ent, 'current_price') %}
          {# TUNING: Rimliga elpriser 0-10 SEK/kWh #}
          {# Ändra övre gräns om du har extrema prisspikar: #}
          {# - Normal marknad: 0-10 SEK/kWh #}
          {# - Extremfall: 0-20 SEK/kWh #}
          {# Lägre gräns är alltid 0 (negativa priser räknas som 0) #}
          {% if p is number and p >= 0 and p <= 10 %}
            {{ p | round(3) }}
          {% else %}
            {{ this.state | float(0) }}
          {% endif %}
        availability: >
          {% set ent = states('input_text.svotc_entity_price') %}
          {% set ent = ent if ent not in ['unknown','unavailable',''] else 'sensor.nordpool_tibber' %}
          {% set p = state_attr(ent, 'current_price') %}
          {{ p is number and p >= 0 and p <= 10 }}


      #########################################################################
      # 2.2 Setpoint logic (Comfort)
      #########################################################################

      - name: "SVOTC Dynamic target temperature"
        unique_id: svotc_dynamic_target_temperature
        unit_of_measurement: "°C"
        device_class: temperature
        state: >
          {# TUNING: Du kan lägga till dynamisk temperatur här #}
          {# Exempel: Sänk på natten, höj på morgonen #}
          {# {% set hour = now().hour %} #}
          {# {% if hour >= 23 or hour < 6 %} #}
          {#   {{ states('input_number.svotc_comfort_temperature') | float(21) - 1 }} #}
          {# {% else %} #}
          {{ states('input_number.svotc_comfort_temperature') | float(21) }}
          {# {% endif %} #}

      #########################################################################
      # 2.3 Percentiles (P30 / P70 / P80) from today+tomorrow raw prices
      #########################################################################

      - name: "SVOTC P30"
        unique_id: svotc_p30
        state: &percentile_logic >
          {% set ent = states('input_text.svotc_entity_price') %}
          {% set ent = ent if ent not in ['unknown','unavailable',''] else 'sensor.nordpool_tibber' %}
          {% set today = state_attr(ent, 'raw_today') | default([], true) %}
          {% set tomorrow = state_attr(ent, 'raw_tomorrow') | default([], true) %}
          {% set combined = today + tomorrow %}
          {% set prices = combined | map(attribute='value') | select('number') | list %}

          {# TUNING: Kräv minst 20 timmar för stabila percentiler #}
          {# Ändra till 24 för att kräva fullständiga data #}
          {# Ändra till 10 för mer tolerans mot ofullständig data #}
          {% if prices | length >= 20 %}
            {% set s = prices | sort %}
            {# TUNING: Percentilvärden kan justeras här #}
            {# P30 = billigt (0.30 = 30:e percentilen) #}
            {# P70 = neutralt (används inte aktivt just nu) #}
            {# P80 = dyrt (0.80 = 80:e percentilen) #}
            {# Ändra 0.30 till 0.25 för striktare "billigt"-definition #}
            {# Ändra 0.80 till 0.85 för striktare "dyrt"-definition #}
            {% set pct = 0.30 if 'P30' in this.name else (0.70 if 'P70' in this.name else 0.80) %}
            {% set idx = ((s | length) * pct) | int %}
            {% set safe_idx = ([0, idx, (s | length - 1)] | sort)[1] %}
            {{ s[safe_idx] | round(3) }}
          {% else %}
            {{ states(this.entity_id) if states(this.entity_id) | is_number else 'unknown' }}
          {% endif %}

      - name: "SVOTC P70"
        unique_id: svotc_p70
        state: *percentile_logic

      - name: "SVOTC P80"
        unique_id: svotc_p80
        state: *percentile_logic


      #########################################################################
      # 2.4 Derived price state + virtual outdoor temp
      #########################################################################

      - name: "SVOTC Current price"
        unique_id: svotc_current_price
        unit_of_measurement: "SEK/kWh"
        state: "{{ states('sensor.svotc_src_current_price') | float(none) }}"

      - name: "SVOTC Raw price state"
        unique_id: svotc_raw_price_state
        state: >
          {% set mode = states('input_select.svotc_mode') %}
          {% if mode in ['Off', 'PassThrough', 'ComfortOnly'] %}
            off
          {% else %}
            {% set p = states('sensor.svotc_src_current_price') | float(none) %}
            {% set p30 = states('sensor.svotc_p30') | float(none) %}
            {% set p80 = states('sensor.svotc_p80') | float(none) %}
            {# TUNING: Prisstatus baseras på percentiler #}
            {# p > P80 = brake (dyrt) #}
            {# p < P30 = cheap (billigt) #}
            {# annars = neutral #}
            {# För mer känsligt system: använd P70 istället för P80 #}
            {# För mindre känsligt: använd P90 istället för P80 #}
            {% if p is number and p80 is number and p > p80 %}
              brake
            {% elif p is number and p30 is number and p < p30 %}
              cheap
            {% else %}
              neutral
            {% endif %}
          {% endif %}

      - name: "SVOTC Virtual outdoor temperature"
        unique_id: svotc_virtual_outdoor_temperature
        unit_of_measurement: "°C"
        device_class: temperature
        state: >
          {% set out = states('sensor.svotc_src_outdoor') | float(none) %}
          {% set off = states('input_number.svotc_applied_offset_c') | float(0) %}
          {% if out is number %}
            {# TUNING: Clamp-gränser för värmepump-säkerhet #}
            {# Standard: -30 till +30°C #}
            {# Justera baserat på din värmepumps specifikationer #}
            {# Om din pump kan hantera -35°C: ändra till -35 #}
            {# Om din pump är känsligare: minska till ±25°C #}
            {{ (out + off) | clamp(-30, 30) | round(2) }}
          {% else %}
            {{ this.state }}
          {% endif %}


      #########################################################################
      # 2.5 Next brake start + pre-brake (LIGHTWEIGHT)
      # - Fix: prebrake should ramp toward the START of the expensive period,
      #   not toward the peak TOP.
      # - We use P80 (brake threshold) and find the first future slot > P80.
      #########################################################################

      - name: "SVOTC Minutes to next brake start"
        unique_id: svotc_minutes_to_next_brake_start
        unit_of_measurement: "min"
        state: >
          {% set ent = states('input_text.svotc_entity_price') %}
          {% set ent = ent if ent not in ['unknown','unavailable',''] else 'sensor.nordpool_tibber' %}
          {% set today = state_attr(ent, 'raw_today') | default([], true) %}
          {% set tomorrow = state_attr(ent, 'raw_tomorrow') | default([], true) %}
          {% set combined = today + tomorrow %}
          {% set p80 = states('sensor.svotc_p80') | float(none) %}
          {% set now_ts = as_timestamp(now()) %}
          {% set ns = namespace(best=none) %}

          {% if p80 is number %}
            {% for it in combined %}
              {% set v = it.value | float(none) %}
              {% set ts = as_timestamp(it.start) if it.start is defined else none %}
              {% if v is number and ts is number and ts >= now_ts and v > p80 %}
                {% set mins = (ts - now_ts) / 60 %}
                {% if ns.best is none or mins < ns.best %}
                  {% set ns.best = mins %}
                {% endif %}
              {% endif %}
            {% endfor %}
          {% endif %}

          {{ ns.best | round(1) if ns.best is not none else 999 }}

    #   - name: "SVOTC Minutes to next peak"
    #     unique_id: svotc_minutes_to_next_peak
    #     unit_of_measurement: "min"
    #     state: >
    #       {% set ent = states('input_text.svotc_entity_price') %}
    #       {% set ent = ent if ent not in ['unknown','unavailable',''] else 'sensor.nordpool_tibber' %}
    #       {% set today = state_attr(ent, 'raw_today') | default([], true) %}
    #       {% set tomorrow = state_attr(ent, 'raw_tomorrow') | default([], true) %}
    #       {% set combined = today + tomorrow %}
    #       {% set peak = states('sensor.svotc_next_peak_price') | float(none) %}
    #       {% if peak is number %}
    #         {% set ns = namespace(best=none) %}
    #         {% for it in combined %}
    #           {% set v = it.value | float(none) %}
    #           {% set ts = as_timestamp(it.start) if it.start is defined else none %}
    #           {# TUNING: Matching-tolerans 0.01 SEK/kWh #}
    #           {# Öka till 0.05 för mer generös matchning #}
    #           {# Minska till 0.005 för striktare matchning #}
    #           {% if v is number and ts is number and (v - peak)|abs < 0.01 and ts >= as_timestamp(now()) %}
    #             {% set mins = (ts - as_timestamp(now())) / 60 %}
    #             {% if ns.best is none or mins < ns.best %}
    #               {% set ns.best = mins %}
    #             {% endif %}
    #           {% endif %}
    #         {% endfor %}
    #         {{ [ns.best | round(1), 0] | max if ns.best is not none else 0 }}
    #       {% else %}
    #         0
    #       {% endif %}


      #########################################################################
      # 2.6 Status + prebrake
      #########################################################################

      - name: "SVOTC Status"
        unique_id: svotc_status
        state: >
          {% set mode = states('input_select.svotc_mode') %}
          {% if is_state('input_boolean.svotc_fail_safe_active','on') %}
            FAIL-SAFE: Sensor error
          {% elif mode == 'Off' %}
            Off
          {% else %}
            {% set r = states('input_text.svotc_reason_code') %}
            {% set mapper = {
              'OFF': 'Off',
              'PASS_THROUGH': 'Pass-through',
              'COMFORT_ONLY': 'Comfort only',
              'MISSING_INDOOR': 'Missing indoor',
              'MCP': 'MCP (comfort)',
              'PRICE_LIMITING_COMFORT': 'Comfort guard',
              'PRICE_BRAKE': 'Braking (price)',
              'COMFORT': 'Comfort'
            } %}
            {{ mapper.get(r, r if r not in ['unknown','unavailable',''] else 'Initialising') }}
          {% endif %}

    #   - name: "SVOTC Prebrake window (min)"
    #     unique_id: svotc_prebrake_window_min
    #     unit_of_measurement: "min"
    #     state: >
    #       {% set a = states('input_number.svotc_brake_aggressiveness') | int(0) %}
    #       {# TUNING: Pre-brake window baserat på aggressiveness #}
    #       {# Detta styr hur många minuter FÖRE pristoppar systemet börjar bromsa #}
    #       {# Standard mapping: #}
    #       {# 0 = 0 min (ingen prebrake) #}
    #       {# 1 = 15 min #}
    #       {# 2 = 30 min #}
    #       {# 3 = 45 min #}
    #       {# 4 = 60 min #}
    #       {# 5 = 75 min #}
    #       {# Ändra värdena nedan för att justera prebrake-timing #}
    #       {% set mapper = {0:0, 1:30, 2:60, 3:90, 4:105, 5:120} %}
    #       {{ mapper.get(a, 0) }}

      - name: "SVOTC Prebrake window (min)"
        unique_id: svotc_prebrake_window_min
        unit_of_measurement: "min"
        state: >
          {% set a = states('input_number.svotc_brake_aggressiveness') | int(0) %}
          {# TUNING: Pre-brake window baserat på aggressiveness #}
          {# Detta styr hur många minuter FÖRE START av dyrperioden systemet börjar bromsa #}
          {% set mapper = {0:0, 1:30, 2:60, 3:90, 4:105, 5:120} %}
          {{ mapper.get(a, 0) }}

      - name: "SVOTC Prebrake strength"
        unique_id: svotc_prebrake_strength
        state: >
          {% set window = states('sensor.svotc_prebrake_window_min') | float(0) %}
          {% set mins = states('sensor.svotc_minutes_to_next_brake_start') | float(999) %}

          {# Prebrake strength ramps linearly from 0 → 1 as we approach
             the START of the next expensive (brake) period. #}
          {% if window > 0 and mins <= window %}
            {{ ((window - mins) / window) | round(3) | clamp(0, 1) }}
          {% else %}
            0
          {% endif %}

      #########################################################################
      # 2.7: Brake phase progress (0-100%)
      #########################################################################

      - name: "SVOTC Brake phase progress"
        unique_id: svotc_brake_phase_progress
        unit_of_measurement: "%"
        state: >
          {% set phase = states('input_text.svotc_brake_phase') %}
          {% if phase == 'idle' %}
            0
          {% else %}
            {% set changed = states('input_datetime.svotc_brake_phase_changed') %}
            {% set changed_ts = as_timestamp(changed) if changed | as_datetime is not none else none %}
            {% if changed_ts is number %}
              {% set elapsed = (as_timestamp(now()) - changed_ts) / 60 %}
              {% set duration = 
                states('input_number.svotc_brake_rampup_duration_min') | float(30) if phase == 'ramping_up'
                else states('input_number.svotc_brake_hold_duration_min') | float(60) if phase == 'holding'
                else states('input_number.svotc_brake_rampdown_duration_min') | float(45) if phase == 'ramping_down'
                else 1 %}
              {{ ((elapsed / duration * 100) | round(1)) | clamp(0, 100) }}
            {% else %}
              0
            {% endif %}
          {% endif %}


  - binary_sensor:

      #########################################################################
      # 2.8 Binary sensors (comfort guard)
      #########################################################################

      - name: "SVOTC Comfort guard active"
        unique_id: svotc_comfort_guard_active
        state: >
          {% set indoor = states('sensor.svotc_src_indoor') | float(none) %}
          {% set target = states('sensor.svotc_dynamic_target_temperature') | float(none) %}
          {% set activate_below = states('input_number.svotc_comfort_guard_activate_below_c') | float(0.8) %}
          {% set deactivate_above = states('input_number.svotc_comfort_guard_deactivate_above_c') | float(0.4) %}
          {% set current = is_state('binary_sensor.svotc_comfort_guard_active','on') %}
          
          {# TUNING: Hysteres-logik #}
          {# activate_below ska vara STÖRRE än deactivate_above för att fungera #}
          {# Exempel: activate=0.8, deactivate=0.4 → hysteres=0.4°C #}
          {# Större skillnad = mer stabilitet men långsammare reaktion #}
          {# Mindre skillnad = snabbare reaktion men risk för oscillation #}
          {# Guard=ON betyder: "det är för kallt → stoppa prisbroms" #}
          {% if indoor is number and target is number %}
            {% if current %}
              {{ indoor < (target - deactivate_above) }}
            {% else %}
              {# Guard är av: aktivera om temp < target - activate_below #}
              {{ indoor < (target - activate_below) }}
            {% endif %}
          {% else %}
            {{ current }}
          {% endif %}

      - name: "SVOTC Price available"
        unique_id: svotc_price_available
        state: "{{ states('sensor.svotc_src_current_price') | is_number }}"

      - name: "SVOTC Brake active"
        unique_id: svotc_brake_active
        state: "{{ is_state('input_text.svotc_last_price_state','brake') }}"

      #########################################################################
      # 2.9 Sensor health monitoring
      #########################################################################

      - name: "SVOTC All sensors healthy"
        unique_id: svotc_all_sensors_healthy
        state: >
          {{ is_state('binary_sensor.svotc_price_available','on')
             and (states('sensor.svotc_src_indoor') | is_number)
             and (states('sensor.svotc_src_outdoor') | is_number) }}

    #   - name: "SVOTC Price bridge"
    #     unique_id: svotc_price_bridge
    #     state: "ok"
    #     attributes:
    #       raw_today: >
    #         {% set ent = states('input_text.svotc_entity_price_today') %}
    #         {% set ent = ent if ent not in ['unknown','unavailable',''] else 'sensor.today_price' %}
    #         {% set lst = state_attr(ent, 'data') | default([], true) %}
    #         {% set ns = namespace(out=[]) %}
    #         {% for it in lst %}
    #           {% if it is mapping %}
    #             {% set v = it.price | float(none) if it.price is defined else none %}
    #             {% set st = it.start if it.start is defined else none %}
    #             {% if v is number and st is not none %}
    #               {% set ns.out = ns.out + [{'start': st, 'value': v}] %}
    #             {% endif %}
    #           {% endif %}
    #         {% endfor %}
    #         {{ ns.out }}

    #       raw_tomorrow: >
    #         {% set ent = states('input_text.svotc_entity_price_tomorrow') %}
    #         {% set ent = ent if ent not in ['unknown','unavailable',''] else 'sensor.tomorrow_price' %}
    #         {% set lst = state_attr(ent, 'data') | default([], true) %}
    #         {% set ns = namespace(out=[]) %}
    #         {% for it in lst %}
    #           {% if it is mapping %}
    #             {% set v = it.price | float(none) if it.price is defined else none %}
    #             {% set st = it.start if it.start is defined else none %}
    #             {% if v is number and st is not none %}
    #               {% set ns.out = ns.out + [{'start': st, 'value': v}] %}
    #             {% endif %}
    #           {% endif %}
    #         {% endfor %}
    #         {{ ns.out }}

    #       current_price: >
    #         {% set ent = states('input_text.svotc_entity_price_today') %}
    #         {% set ent = ent if ent not in ['unknown','unavailable',''] else 'sensor.today_price' %}
    #         {% set lst = state_attr(ent, 'data') | default([], true) %}
    #         {% set now_ts = as_timestamp(now()) %}
    #         {% set ns = namespace(p=none) %}
    #         {% for it in lst %}
    #           {% if it is mapping %}
    #             {% set st = as_timestamp(it.start, default=none) if it.start is defined else none %}
    #             {% set en = as_timestamp(it.end, default=none) if it.end is defined else none %}
    #             {% if st is number and en is number and now_ts >= st and now_ts < en %}
    #               {% set ns.p = it.price | float(none) if it.price is defined else none %}
    #             {% endif %}
    #           {% endif %}
    #         {% endfor %}
    #         {{ ns.p }}

###############################################################################
# 3) Automations
###############################################################################

automation:

  ###########################################################################
  # 3.1 Price dwell med separata tider per övergång
  ###########################################################################
  - alias: "SVOTC Price dwell (improved)"
    id: svotc_price_dwell
    trigger:
      # TUNING: Kontrollfrekvens för price dwell
      # Ändra "/1" till "/5" för att kontrollera var 5:e minut (sparar CPU)
      # Behåll "/1" för bästa reaktionstid
      - platform: time_pattern
        minutes: "/1"
      - platform: state
        entity_id: sensor.svotc_raw_price_state
    action:
      - variables:
          raw: "{{ states('sensor.svotc_raw_price_state') }}"
          stable: "{{ states('input_text.svotc_last_price_state') }}"
          pending: "{{ states('input_text.svotc_pending_price_state') }}"
          last_ch: "{{ states('input_datetime.svotc_last_price_state_changed') }}"
          diff: "{{ (as_timestamp(now()) - as_timestamp(last_ch)) / 60 if last_ch | as_datetime is not none else 999 }}"
          
          # Dynamisk dwell-tid baserat på övergång
          dwell: >
            {% set stable = states('input_text.svotc_last_price_state') %}
            {% set raw = states('sensor.svotc_raw_price_state') %}
            {% if stable == 'cheap' and raw == 'neutral' %}
              {{ states('input_number.svotc_price_dwell_cheap_to_neutral_min') | int(20) }}
            {% elif stable == 'neutral' and raw == 'brake' %}
              {{ states('input_number.svotc_price_dwell_neutral_to_brake_min') | int(30) }}
            {% elif stable == 'brake' and raw == 'neutral' %}
              {{ states('input_number.svotc_price_dwell_brake_to_neutral_min') | int(15) }}
            {% elif stable == 'neutral' and raw == 'cheap' %}
              {{ states('input_number.svotc_price_dwell_neutral_to_cheap_min') | int(10) }}
            {% else %}
              {# TUNING: Fallback dwell-tid för oväntade övergångar #}
              20
            {% endif %}

      - choose:
          - conditions: "{{ raw == stable }}"
            sequence:
              - service: input_text.set_value
                target: { entity_id: input_text.svotc_pending_price_state }
                data: { value: "{{ stable }}" }

          - conditions: "{{ raw != stable and raw != pending }}"
            sequence:
              - service: input_text.set_value
                target: { entity_id: input_text.svotc_pending_price_state }
                data: { value: "{{ raw }}" }
              - service: input_datetime.set_datetime
                target: { entity_id: input_datetime.svotc_last_price_state_changed }
                data: { datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}" }

          - conditions: "{{ raw != stable and raw == pending and diff >= dwell }}"
            sequence:
              - service: input_text.set_value
                target: { entity_id: input_text.svotc_last_price_state }
                data: { value: "{{ raw }}" }
              - service: input_datetime.set_datetime
                target: { entity_id: input_datetime.svotc_last_price_state_changed }
                data: { datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}" }


  ###########################################################################
  # 3.2: Brake phase manager med time_pattern + state machine
  ###########################################################################
  - alias: "SVOTC Brake phase manager (improved)"
    id: svotc_brake_phase_manager
    trigger:
      # FÖRBÄTTRING 1: Time pattern trigger
      # TUNING: Kontrollfrekvens för brake phase
      # "/1" = varje minut (rekommenderat för smooth övergångar)
      # "/5" = var 5:e minut (sparar CPU, men grövre timing)
      - platform: time_pattern
        minutes: "/1"
      - platform: state
        entity_id:
          - input_text.svotc_last_price_state
          - binary_sensor.svotc_comfort_guard_active
          - input_select.svotc_mode
    action:
      - variables:
          mode: "{{ states('input_select.svotc_mode') }}"
          want_brake: >-
            {{ mode not in ['Off','PassThrough','ComfortOnly']
               and is_state('input_text.svotc_last_price_state','brake')
               and is_state('binary_sensor.svotc_comfort_guard_active','off') }}
          phase: "{{ states('input_text.svotc_brake_phase') }}"
          progress: "{{ states('sensor.svotc_brake_phase_progress') | float(0) }}"

      - choose:
          # Mode disables price control → force idle
          - conditions: "{{ mode in ['Off','PassThrough','ComfortOnly'] }}"
            sequence:
              - service: input_text.set_value
                target: { entity_id: input_text.svotc_brake_phase }
                data: { value: "idle" }

          # FÖRBÄTTRING 2: State machine logic
          # idle → ramping_up
          - conditions: "{{ want_brake and phase == 'idle' }}"
            sequence:
              # TUNING: Brake hold offset = aggressiveness × 2.0
              # Ändra multiplikatorn här (2.0 → 1.5 för mildare, 2.5 för hårdare)
              - service: input_number.set_value
                target: { entity_id: input_number.svotc_brake_hold_offset_c }
                data: { value: "{{ (states('input_number.svotc_brake_aggressiveness')|float * 2.0) }}" }
              - service: input_text.set_value
                target: { entity_id: input_text.svotc_brake_phase }
                data: { value: "ramping_up" }
              - service: input_datetime.set_datetime
                target: { entity_id: input_datetime.svotc_brake_phase_changed }
                data: { datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}" }

          # ramping_up → holding
          - conditions: "{{ phase == 'ramping_up' and progress >= 100 }}"
            sequence:
              - service: input_text.set_value
                target: { entity_id: input_text.svotc_brake_phase }
                data: { value: "holding" }
              - service: input_datetime.set_datetime
                target: { entity_id: input_datetime.svotc_brake_phase_changed }
                data: { datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}" }

          # holding → ramping_down
          - conditions: >
              {{ phase == 'holding' and (progress >= 100 or not want_brake) }}
            sequence:
              - service: input_text.set_value
                target: { entity_id: input_text.svotc_brake_phase }
                data: { value: "ramping_down" }
              - service: input_datetime.set_datetime
                target: { entity_id: input_datetime.svotc_brake_phase_changed }
                data: { datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}" }

          # ramping_down → idle
          - conditions: "{{ phase == 'ramping_down' and progress >= 100 }}"
            sequence:
              - service: input_text.set_value
                target: { entity_id: input_text.svotc_brake_phase }
                data: { value: "idle" }
              - service: input_datetime.set_datetime
                target: { entity_id: input_datetime.svotc_brake_phase_changed }
                data: { datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}" }

          # Avbrott: ramping_up → ramping_down
          - conditions: "{{ phase == 'ramping_up' and not want_brake }}"
            sequence:
              - service: input_text.set_value
                target: { entity_id: input_text.svotc_brake_phase }
                data: { value: "ramping_down" }
              - service: input_datetime.set_datetime
                target: { entity_id: input_datetime.svotc_brake_phase_changed }
                data: { datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}" }


  ###########################################################################
  # 3.3 Engine (calculates requested/applied offsets + reason code)
  ###########################################################################
  - alias: "SVOTC Engine"
    id: svotc_engine
    trigger:
      # TUNING: Kontrollfrekvens för huvudmotorn
      # "/1" = varje minut (rekommenderat)
      # "/2" = varannan minut (sparar CPU)
      - platform: time_pattern
        minutes: "/1"
    action:
      - variables:
          mode: "{{ states('input_select.svotc_mode') }}"
          fail_safe: "{{ is_state('input_boolean.svotc_fail_safe_active','on') }}"
          indoor: "{{ states('sensor.svotc_src_indoor') | float(none) }}"
          target: "{{ states('sensor.svotc_dynamic_target_temperature') | float(none) }}"
          brake_aggr: "{{ states('input_number.svotc_brake_aggressiveness') | float(0) }}"
          heat_aggr: "{{ states('input_number.svotc_heat_aggressiveness') | float(0) }}"
          prebrake: "{{ states('sensor.svotc_prebrake_strength') | float(0) }}"
          phase: "{{ states('input_text.svotc_brake_phase') }}"
          progress: "{{ states('sensor.svotc_brake_phase_progress') | float(0) }}"
          guard: "{{ is_state('binary_sensor.svotc_comfort_guard_active','on') }}"

          # Error = Target - Actual (positive => too cold)
          err: "{{ (target - indoor) if indoor is number else 0 }}"
          
          # TUNING: Deadband för MCP (Minimum Comfort Point)
          # 0.4°C = standard (börja värma när 0.4°C under target)
          # Öka till 0.6 för mer tolerans
          # Minska till 0.2 för snabbare reaktion
          deadband: 0.4
          is_heating_comfort: "{{ err > deadband }}"

          # FÖRBÄTTRING 2: Brake multiplier baserat på fas och progress
          brake_multiplier: >
            {% if phase == 'ramping_up' %}
              {{ (progress / 100) | clamp(0, 1) }}
            {% elif phase == 'holding' %}
              1.0
            {% elif phase == 'ramping_down' %}
              {{ (1 - progress / 100) | clamp(0, 1) }}
            {% else %}
              0
            {% endif %}

          # Requested offset
          req: >
            {% if fail_safe or indoor is not number or mode in ['Off', 'PassThrough'] %}
              0
            {% else %}
              {# TUNING: Comfort offset = error × -1.0 #}
              {# Multiplikator -1.0 kan justeras: #}
              {# -0.8 = mildare komfortreglering #}
              {# -1.2 = aggressivare komfortreglering #}
              {% set comfort = (err * -1.0) if err|abs > deadband else 0 %}
              {# TUNING: Offset clamp baserat på aggressiveness #}
              {# Nuvarande: aggressiveness × 2 #}
              {# Ändra till × 1.5 för mildare gränser #}
              {# Ändra till × 2.5 för hårdare gränser #}
              {% set comfort_clamped = comfort | clamp(-(heat_aggr*2), (brake_aggr*2)) %}

              {% if mode == 'ComfortOnly' %}
                {{ comfort_clamped | round(2) }}
              {% else %}
                {% set brake_base = states('input_number.svotc_brake_hold_offset_c')|float %}
                {% set brake_with_prebrake = brake_base * (brake_multiplier|float + prebrake|float) %}
                {% set price = brake_with_prebrake if not guard else 0 %}
                
                {# TUNING: Total offset clamp #}
                {# Standard: ±8°C (säkert för de flesta värmepumpar) #}
                {# Minska till ±6°C för extra försiktighet #}
                {# Öka till ±10°C om din pump klarar det #}
                {{ (comfort_clamped + price) | clamp(-8, 8) | round(2) }}
              {% endif %}
            {% endif %}

          applied_prev: "{{ states('input_number.svotc_applied_offset_c') | float(0) }}"
          max_d: "{{ states('input_number.svotc_max_delta_per_step_c') | float(0.5) }}"
          new_applied: "{{ (applied_prev + ([ -max_d, [ (req - applied_prev), max_d ] | min ] | max)) | round(2) }}"

      # 1) Write Requested Offset
      - service: input_number.set_value
        target: { entity_id: input_number.svotc_requested_offset_c }
        data: { value: "{{ req }}" }

      # 2) Write Applied Offset
      - service: input_number.set_value
        target: { entity_id: input_number.svotc_applied_offset_c }
        data: { value: "{{ new_applied }}" }

      # 3) Update Reason Code
      - service: input_text.set_value
        target: { entity_id: input_text.svotc_reason_code }
        data:
          value: >
            {% if fail_safe %} FAIL_SAFE
            {% elif mode == 'Off' %} OFF
            {% elif mode == 'PassThrough' %} PASS_THROUGH
            {% elif guard %} PRICE_LIMITING_COMFORT
            {% elif (prebrake > 0 or phase in ['ramping_up','holding']) and mode != 'ComfortOnly' %} PRICE_BRAKE
            {% elif is_heating_comfort %} MCP
            {% elif mode == 'ComfortOnly' %} COMFORT_ONLY
            {% else %} COMFORT
            {% endif %}


  ###########################################################################
  # 3.4: Spåra offset-användning per dag
  ###########################################################################
  - alias: "SVOTC Track daily offset hours"
    id: svotc_track_offset_hours
    trigger:
      - platform: time_pattern
        minutes: "/1"
    action:
      - variables:
          applied: "{{ states('input_number.svotc_applied_offset_c') | float(0) }}"
          current_hours: "{{ states('input_number.svotc_total_offset_hours_today') | float(0) }}"
          last_reset: "{{ states('input_datetime.svotc_offset_hours_reset') }}"
          
          # Reset vid midnatt?
          should_reset: >
            {% set lr = as_timestamp(last_reset) if last_reset | as_datetime is not none else 0 %}
            {% set today_midnight = today_at('00:00') | as_timestamp %}
            {{ lr < today_midnight }}

      - choose:
          # Reset counter
          - conditions: "{{ should_reset }}"
            sequence:
              - service: input_number.set_value
                target: { entity_id: input_number.svotc_total_offset_hours_today }
                data: { value: 0 }
              - service: input_datetime.set_datetime
                target: { entity_id: input_datetime.svotc_offset_hours_reset }
                data: { datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}" }

          # TUNING: Tröskel för att räknas som "stor offset"
          # Standard: |offset| > 0.5°C
          # Höj till 1.0 för att bara räkna större offset
          # Sänk till 0.3 för att räkna alla offset
          - conditions: "{{ applied | abs > 0.5 }}"
            sequence:
              - service: input_number.set_value
                target: { entity_id: input_number.svotc_total_offset_hours_today }
                data: { value: "{{ (current_hours + (1/60)) | round(2) }}" }


  ###########################################################################
  # 3.5: Fail-safe automation
  ###########################################################################
  - alias: "SVOTC Fail-safe handler"
    id: svotc_fail_safe_handler
    mode: restart
    trigger:
      - platform: time_pattern
        minutes: "/1"
    action:
      - variables:
          all_ok: "{{ is_state('binary_sensor.svotc_all_sensors_healthy','on') }}"
          fail_safe_active: "{{ is_state('input_boolean.svotc_fail_safe_active','on') }}"

      - choose:
          # TUNING: Fail-safe delay
          # Standard: 5 minuter innan fail-safe aktiveras
          # Öka till 10 för mer tolerans mot korta avbrott
          # Minska till 3 för snabbare säkerhetsreaktion
          - conditions: >
              {{ not all_ok and not fail_safe_active }}
            sequence:
              - delay:
                  minutes: 5
              - condition: template
                value_template: "{{ not is_state('binary_sensor.svotc_all_sensors_healthy','on') }}"
              - service: input_boolean.turn_on
                target: { entity_id: input_boolean.svotc_fail_safe_active }
              - service: input_number.set_value
                target: { entity_id: input_number.svotc_applied_offset_c }
                data: { value: 0 }
              - service: persistent_notification.create
                data:
                  title: "⚠️ SVOTC FAIL-SAFE AKTIVERAD"
                  message: >
                    En eller flera sensorer saknar giltiga värden i >5 min.
                    Offset nollställd för säkerhet.

          # TUNING: Recovery delay
          # Standard: 3 minuter innan fail-safe släpper
          # Öka till 5 för mer stabil återställning
          # Minska till 2 för snabbare återgång
          - conditions: >
              {{ all_ok and fail_safe_active }}
            sequence:
              - delay:
                  minutes: 3
              - condition: template
                value_template: "{{ is_state('binary_sensor.svotc_all_sensors_healthy','on') }}"
              - service: input_boolean.turn_off
                target: { entity_id: input_boolean.svotc_fail_safe_active }
              - service: persistent_notification.create
                data:
                  title: "✅ SVOTC FAIL-SAFE AVAKTIVERAD"
                  message: "Alla sensorer fungerar igen."


  ###########################################################################
  # 3.6: Missing inputs (använd konfigurerbar notifier)
  ###########################################################################
  - alias: "SVOTC Notify: missing inputs"
    id: svotc_notify_missing_inputs
    mode: single
    trigger:
      # TUNING: Delay innan notifikation vid saknad sensor
      # Standard: 3 minuter
      # Öka till 5 för att undvika spam vid korta avbrott
      # Minska till 1 för snabbare varningar
      - platform: state
        entity_id: binary_sensor.svotc_price_available
        to: "off"
        for:
          minutes: 3

      - platform: template
        value_template: >
          {{ not (states('sensor.svotc_src_indoor') | is_number) }}
        for:
          minutes: 3

      - platform: template
        value_template: >
          {{ not (states('sensor.svotc_src_outdoor') | is_number) }}
        for:
          minutes: 3

      # TUNING: Delay innan "recovered"-notifikation
      # Standard: 2 minuter
      # Öka till 5 för att vara säker på att det är stabilt
      - platform: template
        value_template: >
          {{ is_state('binary_sensor.svotc_price_available','on')
             and (states('sensor.svotc_src_indoor') | is_number)
             and (states('sensor.svotc_src_outdoor') | is_number) }}
        for:
          minutes: 2

    action:
      - variables:
          price_ok: "{{ is_state('binary_sensor.svotc_price_available','on') }}"
          indoor_ok: "{{ states('sensor.svotc_src_indoor') | is_number }}"
          outdoor_ok: "{{ states('sensor.svotc_src_outdoor') | is_number }}"
          all_ok: "{{ price_ok and indoor_ok and outdoor_ok }}"

          ent_price: "{{ states('input_text.svotc_entity_price') }}"
          ent_indoor: "{{ states('input_text.svotc_entity_indoor') }}"
          ent_outdoor: "{{ states('input_text.svotc_entity_outdoor') }}"
          
          # FÖRBÄTTRING 6: Konfigurerbar notifier
          notifier: "{{ states('input_text.svotc_notifier') }}"

          missing_list: >
            {% set m = [] %}
            {% if not price_ok %}{% set m = m + ['Elpris'] %}{% endif %}
            {% if not indoor_ok %}{% set m = m + ['Innetemp'] %}{% endif %}
            {% if not outdoor_ok %}{% set m = m + ['Utetemp'] %}{% endif %}
            {{ m | join(', ') if m|length > 0 else '—' }}

          details: >
            {% set lines = [] %}
            {% if not price_ok %}{% set lines = lines + ['Pris: ' ~ ent_price] %}{% endif %}
            {% if not indoor_ok %}{% set lines = lines + ['Inne: ' ~ ent_indoor] %}{% endif %}
            {% if not outdoor_ok %}{% set lines = lines + ['Ute: ' ~ ent_outdoor] %}{% endif %}
            {{ lines | join('\n') }}

      - choose:
          - conditions: >
              {{ (not all_ok) and is_state('input_boolean.svotc_missing_inputs_alerted','off') }}
            sequence:
              - service: input_boolean.turn_on
                target: { entity_id: input_boolean.svotc_missing_inputs_alerted }

              - service: persistent_notification.create
                data:
                  title: "SVOTC: Saknar input"
                  message: >
                    Saknar: {{ missing_list }}.
                    {{ details }}

              # FÖRBÄTTRING 6: Använd konfigurerbar notifier
              - service: "{{ notifier }}"
                data:
                  title: "SVOTC: Saknar input"
                  message: "Saknar: {{ missing_list }}"

          - conditions: >
              {{ all_ok and is_state('input_boolean.svotc_missing_inputs_alerted','on') }}
            sequence:
              - service: input_boolean.turn_off
                target: { entity_id: input_boolean.svotc_missing_inputs_alerted }

              - service: persistent_notification.create
                data:
                  title: "SVOTC: Input återställd"
                  message: "Alla input OK igen."

              - service: "{{ notifier }}"
                data:
                  title: "SVOTC: Input återställd"
                  message: "Alla sensorer fungerar."


###############################################################################
# 4: Recorder configuration för historik
# 
# TUNING: Retention och purge
# Justera recorder-inställningar i configuration.yaml:
# recorder:
#   purge_keep_days: 7    # Behåll historik i 7 dagar (öka för längre historik)
#   commit_interval: 5    # Spara till disk var 5:e sekund
###############################################################################
# recorder:
#   include:
#     entities:
#       # Källsensorer
#       - sensor.svotc_src_indoor
#       - sensor.svotc_src_outdoor
#       - sensor.svotc_src_current_price
      
#       # Priser och percentiler
#       - sensor.svotc_current_price
#       - sensor.svotc_p30
#       - sensor.svotc_p70
#       - sensor.svotc_p80
      
#       # Virtuell temp och offset
#       - sensor.svotc_virtual_outdoor_temperature
#       - input_number.svotc_requested_offset_c
#       - input_number.svotc_applied_offset_c
      
#       # Status och fas
#       - input_text.svotc_reason_code
#       - input_text.svotc_brake_phase
#       - sensor.svotc_brake_phase_progress
#       - input_text.svotc_last_price_state
      
#       # Guards och health
#       - binary_sensor.svotc_comfort_guard_active
#       - input_number.svotc_total_offset_hours_today
#       - binary_sensor.svotc_all_sensors_healthy
#       - input_boolean.svotc_fail_safe_active

#       # Prebrake
#       - sensor.svotc_prebrake_strength
#       - sensor.svotc_minutes_to_next_brake_start

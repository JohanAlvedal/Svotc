###############################################################################
# SVOTC package (YAML engine) - IMPROVED VERSION                             #
# - Logic: stable + explainable                                               #
# - Uses Nordpool Tibber attributes: current_price, raw_today, raw_tomorrow   #
# - Fixes: percentile calculation, safety limits, anti-cycling, failsafes     #
###############################################################################

input_select:
  svotc_mode:
    name: "SVOTC Mode"
    options:
      - "Off"
      - "Smart"
      - "Vacation"
      - "PassThrough"
      - "ComfortOnly"

input_number:
  svotc_brake_aggressiveness:
    name: "SVOTC Brake aggressiveness"
    min: 0
    max: 5
    step: 1
    mode: slider

  svotc_heat_aggressiveness:
    name: "SVOTC Heat aggressiveness"
    min: 0
    max: 5
    step: 1
    mode: slider

  svotc_comfort_temperature:
    name: "SVOTC Comfort temperature"
    min: 15
    max: 25
    step: 0.1
    mode: box

  svotc_vacation_temperature:
    name: "SVOTC Vacation temperature"
    min: 10
    max: 22  # FIXED: Reduced from 25 to enforce energy saving
    step: 0.1
    mode: box

  svotc_requested_offset_c:
    name: "SVOTC Requested offset (C)"
    min: -10
    max: 10
    step: 0.1
    mode: box

  svotc_applied_offset_c:
    name: "SVOTC Applied offset (C)"
    min: -10
    max: 10
    step: 0.1
    mode: box

  svotc_max_delta_per_step_c:
    name: "SVOTC Max delta per step (C)"
    min: 0.1
    max: 5
    step: 0.1
    mode: box

  svotc_comfort_guard_deadband_c:
    name: "SVOTC Comfort guard deadband (C)"
    min: 0.0
    max: 2.0
    step: 0.1
    mode: box

  svotc_price_dwell_minutes:
    name: "SVOTC Price dwell (min)"
    min: 5  # FIXED: Minimum 5 min to avoid too rapid switching
    max: 120
    step: 1
    mode: box

  svotc_brake_hold_offset_c:
    name: "SVOTC Brake hold offset (C)"
    min: 0
    max: 10
    step: 0.1
    mode: box

  # NEW: Anti-cycling protection
  svotc_min_phase_duration_minutes:
    name: "SVOTC Min phase duration (min)"
    min: 10
    max: 120
    step: 5
    initial: 30
    mode: slider

  # NEW: Maximum total offset safety limit
  svotc_max_total_offset_c:
    name: "SVOTC Max total offset (C)"
    min: 5
    max: 15
    step: 0.5
    initial: 8
    mode: slider

input_text:
  svotc_reason_code:
    name: "SVOTC Reason code"
  svotc_last_price_state:
    name: "SVOTC Last price state"
  svotc_pending_price_state:
    name: "SVOTC Pending price state"
  svotc_brake_phase:
    name: "SVOTC Brake phase"

input_datetime:
  svotc_last_price_state_changed:
    name: "SVOTC Last price state changed"
    has_date: true
    has_time: true
  svotc_brake_phase_changed:
    name: "SVOTC Brake phase changed"
    has_date: true
    has_time: true

input_boolean:
  # NEW: Emergency failsafe flag
  svotc_sensor_failure_detected:
    name: "SVOTC Sensor failure detected"
    initial: false

template:
  - sensor:
      - name: "SVOTC Src Indoor"
        unique_id: svotc_src_indoor
        unit_of_measurement: "째C"
        device_class: temperature
        state_class: measurement
        state: "{{ states('sensor.inomhusmedel') | float(none) }}"
        availability: "{{ states('sensor.inomhusmedel') | is_number }}"

      - name: "SVOTC Src Outdoor"
        unique_id: svotc_src_outdoor
        unit_of_measurement: "째C"
        device_class: temperature
        state_class: measurement
        state: "{{ states('sensor.temperatur_nu') | float(none) }}"
        availability: "{{ states('sensor.temperatur_nu') | is_number }}"

      - name: "SVOTC Src Current Price"
        unique_id: svotc_src_current_price
        unit_of_measurement: "SEK/kWh"
        state: >
          {% set p = state_attr('sensor.nordpool_tibber', 'current_price') %}
          {{ p | round(3) if p is number else this.state | float(0) }}
        availability: "{{ state_attr('sensor.nordpool_tibber', 'current_price') is number }}"

      - name: "SVOTC Dynamic target temperature"
        unique_id: svotc_dynamic_target_temperature
        unit_of_measurement: "째C"
        device_class: temperature
        state: >
          {% set mode = states('input_select.svotc_mode') %}
          {% if mode == 'Vacation' %}
            {{ states('input_number.svotc_vacation_temperature') | float(18) }}
          {% else %}
            {{ states('input_number.svotc_comfort_temperature') | float(21) }}
          {% endif %}

      - name: "SVOTC P30"
        unique_id: svotc_p30
        state: &percentile_logic >
          {% set today = state_attr('sensor.nordpool_tibber', 'raw_today') | default([], true) %}
          {% set tomorrow = state_attr('sensor.nordpool_tibber', 'raw_tomorrow') | default([], true) %}
          {% set combined = today + tomorrow %}
          {% set prices = combined | map(attribute='value') | select('number') | list %}
          
          {% if prices | length >= 10 %}
            {% set s = prices | sort %}
            {# FIXED: Improved percentile calculation #}
            {% set pct = 0.30 if 'P30' in this.name else (0.70 if 'P70' in this.name else 0.80) %}
            {% set idx = (((s | length - 1) * pct) | round | int) %}
            {{ s[idx] | round(3) }}
          {% else %}
            {{ states(this.entity_id) if states(this.entity_id) | is_number else 'unknown' }}
          {% endif %}

      - name: "SVOTC P70"
        unique_id: svotc_p70
        state: *percentile_logic

      - name: "SVOTC P80"
        unique_id: svotc_p80
        state: *percentile_logic

      - name: "SVOTC Current price"
        unique_id: svotc_current_price
        unit_of_measurement: "SEK/kWh"
        state: "{{ states('sensor.svotc_src_current_price') | float(none) }}"

      - name: "SVOTC Raw price state"
        unique_id: svotc_raw_price_state
        state: >
          {% set mode = states('input_select.svotc_mode') %}
          {% if mode in ['Off', 'PassThrough', 'ComfortOnly'] %} off
          {% else %}
            {% set p = states('sensor.svotc_src_current_price') | float(none) %}
            {% set p30 = states('sensor.svotc_p30') | float(none) %}
            {% set p80 = states('sensor.svotc_p80') | float(none) %}
            {% if p is number and p80 is number and p > p80 %} brake
            {% elif p is number and p30 is number and p < p30 %} cheap
            {% else %} neutral {% endif %}
          {% endif %}

      - name: "SVOTC Virtual outdoor temperature"
        unique_id: svotc_virtual_outdoor_temperature
        unit_of_measurement: "째C"
        device_class: temperature
        state: >
          {% set out = states('sensor.svotc_src_outdoor') | float(none) %}
          {% set off = states('input_number.svotc_applied_offset_c') | float(0) %}
          {% if out is number %}
            {# IMPROVED: Stricter clamping to prevent extreme virtual temps #}
            {% set virtual = out + off %}
            {% set max_offset = states('input_number.svotc_max_total_offset_c') | float(8) %}
            {% set safe_virtual = virtual | clamp(out - max_offset, out + max_offset) %}
            {{ safe_virtual | clamp(-25, 30) | round(2) }}
          {% else %}
            {{ this.state }}
          {% endif %}

      - name: "SVOTC Next peak price"
        unique_id: svotc_next_peak_price
        unit_of_measurement: "SEK/kWh"
        state: >
          {% set today = state_attr('sensor.nordpool_tibber', 'raw_today') | default([], true) %}
          {% set tomorrow = state_attr('sensor.nordpool_tibber', 'raw_tomorrow') | default([], true) %}
          {% set combined = today + tomorrow %}
          {% set window = states('sensor.svotc_prebrake_window_min') | float(0) %}
          {% set horizon_m = (window + 30) | clamp(15, 180) %}
          {% set now_ts = as_timestamp(now()) %}
          {% set end_ts = now_ts + (horizon_m * 60) %}
          {% set ns = namespace(vals=[]) %}
          {% for it in combined %}
            {% set v = it.value | float(none) %}
            {% set ts = as_timestamp(it.start) if it.start is defined else none %}
            {% if v is number and ts is number and ts >= (now_ts - 3600) and ts <= end_ts %}
              {% set ns.vals = ns.vals + [v] %}
            {% endif %}
          {% endfor %}
          {{ (ns.vals | max | round(3)) if ns.vals | length > 0 else states('sensor.svotc_src_current_price') }}

      - name: "SVOTC Minutes to next peak"
        unique_id: svotc_minutes_to_next_peak
        unit_of_measurement: "min"
        state: >
          {% set today = state_attr('sensor.nordpool_tibber', 'raw_today') | default([], true) %}
          {% set tomorrow = state_attr('sensor.nordpool_tibber', 'raw_tomorrow') | default([], true) %}
          {% set combined = today + tomorrow %}
          {% set peak = states('sensor.svotc_next_peak_price') | float(none) %}
          {% if peak is number %}
            {% set ns = namespace(best=none) %}
            {% for it in combined %}
              {% set v = it.value | float(none) %}
              {% set ts = as_timestamp(it.start) if it.start is defined else none %}
              {% if v is number and ts is number and (v - peak)|abs < 0.001 and ts >= as_timestamp(now()) %}
                {% set mins = (ts - as_timestamp(now())) / 60 %}
                {% if ns.best is none or mins < ns.best %}{% set ns.best = mins %}{% endif %}
              {% endif %}
            {% endfor %}
            {{ [ns.best | round(1), 0] | max if ns.best is not none else 0 }}
          {% else %} 0 {% endif %}

      - name: "SVOTC Status"
        unique_id: svotc_status
        state: >
          {% set mode = states('input_select.svotc_mode') %}
          {% if mode == 'Off' %} Off
          {% elif is_state('input_boolean.svotc_sensor_failure_detected', 'on') %} SENSOR FAILURE - SAFE MODE
          {% else %}
            {% set r = states('input_text.svotc_reason_code') %}
            {% set mapper = {
              'OFF': 'Off',
              'PASS_THROUGH': 'Pass-through (no control)',
              'COMFORT_ONLY': 'Comfort only',
              'MISSING_INDOOR': 'Missing indoor (safe mode)',
              'COMFORT_GUARD': 'Comfort guard active',
              'PRICE_BRAKE': 'Braking (high price)',
              'PRICE_CHEAP_HEAT': 'Extra heating (low price)',
              'COMFORT': 'Comfort mode',
              'SAFE_MODE': 'Safe mode (sensor issue)'
            } %}
            {{ mapper.get(r, r if r not in ['unknown','unavailable',''] else 'Initialising') }}
          {% endif %}

      - name: "SVOTC Prebrake window (min)"
        unique_id: svotc_prebrake_window_min
        unit_of_measurement: "min"
        state: >
          {% set a = states('input_number.svotc_brake_aggressiveness') | int(0) %}
          {# ADJUSTED: Less aggressive prebrake timing #}
          {% set mapper = {0:0, 1:3, 2:8, 3:15, 4:25, 5:40} %}
          {{ mapper.get(a, 0) }}

      - name: "SVOTC Prebrake strength"
        unique_id: svotc_prebrake_strength
        state: >
          {% set window = states('sensor.svotc_prebrake_window_min') | float(0) %}
          {% set mins = states('sensor.svotc_minutes_to_next_peak') | float(999) %}
          {% set peak = states('sensor.svotc_next_peak_price') | float(0) %}
          {% set p80 = states('sensor.svotc_p80') | float(0) %}
          {% if window > 0 and peak > p80 and mins <= window %}
            {{ ((window - mins) / window) | round(3) | clamp(0, 1) }}
          {% else %} 0 {% endif %}

      # NEW: Phase duration monitoring
      - name: "SVOTC Phase duration (min)"
        unique_id: svotc_phase_duration_min
        unit_of_measurement: "min"
        state: >
          {% set last_change = states('input_datetime.svotc_brake_phase_changed') %}
          {% if last_change | as_datetime is not none %}
            {{ ((as_timestamp(now()) - as_timestamp(last_change)) / 60) | round(1) }}
          {% else %} 0 {% endif %}

  - binary_sensor:
      - name: "SVOTC Comfort guard active"
        unique_id: svotc_comfort_guard_active
        state: >
          {% set indoor = states('sensor.svotc_src_indoor') | float(none) %}
          {% set target = states('sensor.svotc_dynamic_target_temperature') | float(none) %}
          {% set db = states('input_number.svotc_comfort_guard_deadband_c') | float(1) %}
          {{ indoor < (target - db) if indoor is number and target is number else false }}

      - name: "SVOTC Price available"
        unique_id: svotc_price_available
        state: "{{ states('sensor.svotc_src_current_price') | is_number }}"

      - name: "SVOTC Brake active"
        unique_id: svotc_brake_active
        state: "{{ is_state('input_text.svotc_last_price_state','brake') }}"

      # NEW: Sensor health monitoring
      - name: "SVOTC Sensors healthy"
        unique_id: svotc_sensors_healthy
        state: >
          {% set indoor = states('sensor.svotc_src_indoor') | is_number %}
          {% set outdoor = states('sensor.svotc_src_outdoor') | is_number %}
          {{ indoor and outdoor }}

automation:
  # NEW: Sensor health monitor
  - alias: "SVOTC Sensor health monitor"
    id: svotc_sensor_health_monitor
    trigger:
      - platform: time_pattern
        minutes: "/1"
    action:
      - variables:
          healthy: "{{ is_state('binary_sensor.svotc_sensors_healthy', 'on') }}"
          failure: "{{ is_state('input_boolean.svotc_sensor_failure_detected', 'on') }}"
      - choose:
          - conditions: "{{ not healthy and not failure }}"
            sequence:
              - service: input_boolean.turn_on
                target: { entity_id: input_boolean.svotc_sensor_failure_detected }
              - service: input_number.set_value
                target: { entity_id: input_number.svotc_applied_offset_c }
                data: { value: 0 }
              - service: persistent_notification.create
                data:
                  title: "SVOTC Sensor Failure"
                  message: "Temperature sensors unavailable. System entering safe mode (offset = 0)."
                  notification_id: svotc_sensor_failure
          - conditions: "{{ healthy and failure }}"
            sequence:
              - service: input_boolean.turn_off
                target: { entity_id: input_boolean.svotc_sensor_failure_detected }
              - service: persistent_notification.dismiss
                data:
                  notification_id: svotc_sensor_failure

  - alias: "SVOTC Price dwell"
    id: svotc_price_dwell
    trigger:
      - platform: time_pattern
        minutes: "/1"
      - platform: state
        entity_id: sensor.svotc_raw_price_state
    action:
      - variables:
          raw: "{{ states('sensor.svotc_raw_price_state') }}"
          stable: "{{ states('input_text.svotc_last_price_state') }}"
          pending: "{{ states('input_text.svotc_pending_price_state') }}"
          dwell: "{{ states('input_number.svotc_price_dwell_minutes') | int(30) }}"
          last_ch: "{{ states('input_datetime.svotc_last_price_state_changed') }}"
          diff: "{{ (as_timestamp(now()) - as_timestamp(last_ch)) / 60 if last_ch | as_datetime is not none else 999 }}"
      - choose:
          - conditions: "{{ raw == stable }}"
            sequence:
              - service: input_text.set_value
                target: { entity_id: input_text.svotc_pending_price_state }
                data: { value: "{{ stable }}" }
          - conditions: "{{ raw != stable and raw != pending }}"
            sequence:
              - service: input_text.set_value
                target: { entity_id: input_text.svotc_pending_price_state }
                data: { value: "{{ raw }}" }
              - service: input_datetime.set_datetime
                target: { entity_id: input_datetime.svotc_last_price_state_changed }
                data: { datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}" }
          - conditions: "{{ raw != stable and raw == pending and diff >= dwell }}"
            sequence:
              - service: input_text.set_value
                target: { entity_id: input_text.svotc_last_price_state }
                data: { value: "{{ raw }}" }
              - service: input_datetime.set_datetime
                target: { entity_id: input_datetime.svotc_last_price_state_changed }
                data: { datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}" }

  - alias: "SVOTC Brake phase manager"
    id: svotc_brake_phase_manager
    trigger:
      - platform: time_pattern
        minutes: "/1"
      - platform: state
        entity_id: 
          - input_text.svotc_last_price_state
          - binary_sensor.svotc_comfort_guard_active
          - input_select.svotc_mode
    action:
      - variables:
          mode: "{{ states('input_select.svotc_mode') }}"
          want_brake: >-
            {{ mode not in ['Off','PassThrough','ComfortOnly']
               and is_state('input_text.svotc_last_price_state','brake')
               and is_state('binary_sensor.svotc_comfort_guard_active','off') }}
          phase: "{{ states('input_text.svotc_brake_phase') }}"
          phase_duration: "{{ states('sensor.svotc_phase_duration_min') | float(0) }}"
          min_duration: "{{ states('input_number.svotc_min_phase_duration_minutes') | float(30) }}"
          can_change_phase: "{{ phase_duration >= min_duration or phase == 'idle' }}"
      - choose:
          # If mode disables price control, force phase to idle.
          - conditions: "{{ mode in ['Off','PassThrough','ComfortOnly'] }}"
            sequence:
              - service: input_text.set_value
                target: { entity_id: input_text.svotc_brake_phase }
                data: { value: "idle" }
              - service: input_datetime.set_datetime
                target: { entity_id: input_datetime.svotc_brake_phase_changed }
                data: { datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}" }

          # IMPROVED: Comfort guard overrides brake even in holding phase
          - conditions: >-
              {{ phase in ['ramping_up','holding'] 
                 and is_state('binary_sensor.svotc_comfort_guard_active','on') }}
            sequence:
              - service: input_text.set_value
                target: { entity_id: input_text.svotc_brake_phase }
                data: { value: "ramping_down" }
              - service: input_datetime.set_datetime
                target: { entity_id: input_datetime.svotc_brake_phase_changed }
                data: { datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}" }

          # IMPROVED: Anti-cycling - only change phase if minimum duration met
          - conditions: "{{ want_brake and can_change_phase }}"
            sequence:
              - service: input_number.set_value
                target: { entity_id: input_number.svotc_brake_hold_offset_c }
                data: { value: "{{ (states('input_number.svotc_brake_aggressiveness')|float * 2.0) }}" }
              - if: "{{ phase not in ['ramping_up','holding'] }}"
                then:
                  - service: input_text.set_value
                    target: { entity_id: input_text.svotc_brake_phase }
                    data: { value: "ramping_up" }
                  - service: input_datetime.set_datetime
                    target: { entity_id: input_datetime.svotc_brake_phase_changed }
                    data: { datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}" }

          - conditions: "{{ not want_brake and phase in ['ramping_up','holding'] and can_change_phase }}"
            sequence:
              - service: input_text.set_value
                target: { entity_id: input_text.svotc_brake_phase }
                data: { value: "ramping_down" }
              - service: input_datetime.set_datetime
                target: { entity_id: input_datetime.svotc_brake_phase_changed }
                data: { datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}" }

  - alias: "SVOTC Engine"
    id: svotc_engine
    trigger:
      - platform: time_pattern
        minutes: "/1"
    action:
      - variables:
          mode: "{{ states('input_select.svotc_mode') }}"
          sensor_failure: "{{ is_state('input_boolean.svotc_sensor_failure_detected', 'on') }}"
          indoor: "{{ states('sensor.svotc_src_indoor') | float(none) }}"
          target: "{{ states('sensor.svotc_dynamic_target_temperature') | float(none) }}"
          brake_aggr: "{{ states('input_number.svotc_brake_aggressiveness') | float(0) }}"
          heat_aggr: "{{ states('input_number.svotc_heat_aggressiveness') | float(0) }}"
          prebrake: "{{ states('sensor.svotc_prebrake_strength') | float(0) }}"
          phase: "{{ states('input_text.svotc_brake_phase') }}"
          guard: "{{ is_state('binary_sensor.svotc_comfort_guard_active','on') }}"
          price_state: "{{ states('input_text.svotc_last_price_state') }}"
          
          req: >
            {% if sensor_failure %} 0
            {% elif indoor is not number %} 0
            {% elif mode == 'Off' %} 0
            {% elif mode == 'PassThrough' %} 0
            {% else %}
              {% set err = target - indoor %}
              {% set comfort = (err * -1.0) if err|abs > 0.4 else 0 %}
              {# IMPROVED: Better limits based on heat vs brake aggressiveness #}
              {% set max_heat = heat_aggr * 2.5 %}
              {% set max_brake = brake_aggr * 2.0 %}
              {% set comfort_clamped = comfort | clamp(-max_heat, max_brake) %}

              {# ComfortOnly = no price term, ever #}
              {% if mode == 'ComfortOnly' %}
                {{ comfort_clamped | clamp(-10, 10) | round(2) }}
              {% else %}
                {# IMPROVED: Separate logic for cheap heating vs expensive braking #}
                {% set price_offset = 0 %}
                
                {# Brake logic - only if not comfort guarded #}
                {% if not guard and phase in ['ramping_up','holding'] %}
                  {% set brake_hold = states('input_number.svotc_brake_hold_offset_c')|float %}
                  {% set price_offset = brake_hold * prebrake %}
                {% endif %}
                
                {# IMPROVED: Cheap heating bonus when price is low #}
                {% if price_state == 'cheap' and not guard %}
                  {% set cheap_boost = heat_aggr * 1.5 %}
                  {% set price_offset = price_offset - cheap_boost %}
                {% endif %}
                
                {% set total = comfort_clamped + price_offset %}
                {% set max_total = states('input_number.svotc_max_total_offset_c')|float(8) %}
                {{ total | clamp(-max_total, max_total) | round(2) }}
              {% endif %}
            {% endif %}
          
          applied_prev: "{{ states('input_number.svotc_applied_offset_c') | float(0) }}"
          max_d: "{{ states('input_number.svotc_max_delta_per_step_c') | float(0.5) }}"
          new_applied: "{{ (applied_prev + ([ -max_d, [ (req - applied_prev), max_d ] | min ] | max)) | round(2) }}"

      - service: input_number.set_value
        target: { entity_id: input_number.svotc_requested_offset_c }
        data: { value: "{{ req }}" }
      - service: input_number.set_value
        target: { entity_id: input_number.svotc_applied_offset_c }
        data: { value: "{{ new_applied }}" }

      - service: input_text.set_value
        target: { entity_id: input_text.svotc_reason_code }
        data:
          value: >
            {% if sensor_failure %} SAFE_MODE
            {% elif mode == 'Off' %} OFF
            {% elif mode == 'PassThrough' %} PASS_THROUGH
            {% elif mode == 'ComfortOnly' %} COMFORT_ONLY
            {% elif guard %} COMFORT_GUARD
            {% elif prebrake > 0 and phase in ['ramping_up','holding'] %} PRICE_BRAKE
            {% elif price_state == 'cheap' %} PRICE_CHEAP_HEAT
            {% else %} COMFORT {% endif %}

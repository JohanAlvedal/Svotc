###############################################################################
## SVOTC – Stable Core Edition (2026-02-11)     Made By Johan Ä                                       
##
## CONTENTS:
##   1. UI / Controls (Helpers)
##      1.1 USER SETTINGS (modify these)
##          - Mode selection
##          - Comfort settings
##          - Price controls
##          - Dwell times
##          - Brake phase settings
##          - Rate limiting
##      1.2 SYSTEM STATE (read-only / automatic)
##          - Engine outputs
##      1.3 CONFIGURATION (set once, rarely changed)
##          - Entity mapping
##      1.4 INTERNAL STATE (read-only / automatic)
##          - State machine memory
##          - Timestamps
##
##   2. Sensing & Planning Sensors
##      2.1 Indoor temperature (validated)
##      2.2 Outdoor temperature (validated)
##      2.3 Current price (validated)
##      2.4 Dynamic target temperature
##      2.5 Percentiles P30/P80
##      2.6 Raw price state (instant)
##      2.7 Forward look (minutes to brake)
##      2.8 Prebrake window & strength
##      2.9 Virtual outdoor temperature
##      2.10 "When ON: comfort protection is active and can override price saving."
##
##   3. Automations (State Machines)
##      3.1 Price dwell (raw → stable)
##      3.2 Brake phase controller
##      3.3 Engine (requested → applied offset)
##      3.4 Notify (diagnostics) - alert only if bad state persists
##      3.5 SVOTC Preset: Simple (Ngenic-style)
##
## Purpose: Stable + explainable SVOTC core with strict layering:
##   1) Sensing (validated raw inputs)
##   2) Raw price state (instant/no memory)
##   3) Dwell (raw -> stable, with pending + timestamp)
##   4) Forward look (prebrake_strength)
##   5) Brake phase memory (idle/ramping_up/holding/ramping_down)
##   6) Engine (requested offset -> ramp-limited applied offset)
##
## INSTALL (REQUIRED):
##  - Set input_text.svotc_entity_indoor  = your indoor temperature sensor entity_id
##  - Set input_text.svotc_entity_outdoor = your outdoor temperature sensor entity_id
##  - Set input_text.svotc_entity_price   = your Nordpool price sensor entity_id
##
## INSTALL (OPTIONAL - NOTIFICATIONS):
##  - Set input_text.svotc_notify_service = notify.mobile_app_<your_device>
##     (leave empty → uses notify.notify)
##
## KEY FIXES IN THIS VERSION:
## - Added comfor guard switch
###############################################################################
## SVOTC Recommended Defaults (Optimized for 15‑minute electricity prices)
##
## Comfort settings:
##   svotc_comfort_temperature:                21.0
##   svotc_comfort_guard_activate_below_c:     0.8
##   svotc_comfort_guard_deactivate_above_c:   0.3
##
## Price control:
##   svotc_brake_aggressiveness:               2   # 30 min prebrake window
##   svotc_heat_aggressiveness:                2
##   svotc_brake_hold_offset_c:                6.0
##
## Dwell times (must be < 15 min for quarter-hour pricing):
##   svotc_price_dwell_cheap_to_neutral_min:   8
##   svotc_price_dwell_neutral_to_brake_min:   8
##   svotc_price_dwell_brake_to_neutral_min:   8
##   svotc_price_dwell_neutral_to_cheap_min:   8
##
## Brake phase durations:
##   svotc_brake_rampup_duration_min:          20
##   svotc_brake_hold_duration_min:            15
##   svotc_brake_rampdown_duration_min:        25
##
## Rate limiting:
##   svotc_max_delta_per_step_c:               0.20
##
## Mode:
##   svotc_mode: Smart
###############################################################################
## 1. UI / Controls (Helpers)
###############################################################################

  #############################################################################
  ## 1.1 USER SETTINGS (Modify these to control SVOTC behavior)
  #############################################################################

input_select:
  # --- Mode Selection ---
  svotc_mode:
    name: "SVOTC Mode"
    options: ["Off", "Smart", "Simple", "PassThrough", "ComfortOnly"]
    # Off          - System disabled, no offset applied
    # Smart        - Full automatic control (comfort + price)
    # PassThrough  - No offset, just monitoring
    # ComfortOnly  - Only comfort guard, no price control

input_number:
  # --- Comfort Settings ---
  svotc_comfort_temperature:
    name: "Comfort temperature"
    min: 15
    max: 25
    step: 0.1
    mode: box
    # Target indoor temperature for comfort guard

  svotc_comfort_guard_activate_below_c:
    name: "Comfort guard activate (below target)"
    min: 0.2
    max: 3.0
    step: 0.1
    mode: box
    # Activate comfort guard when indoor temp drops this much below target

  svotc_comfort_guard_deactivate_above_c:
    name: "Comfort guard deactivate (above target)"
    min: 0.1
    max: 2.0
    step: 0.1
    mode: box
    # Deactivate comfort guard when indoor temp rises to this much below target

  # --- Price Control Settings ---
  svotc_brake_aggressiveness:
    name: "Brake aggressiveness"
    min: 0
    max: 5
    step: 1
    mode: slider
    # 0 = No prebrake, 5 = Maximum (120 min prebrake window)
    # Controls how early the system starts reducing heat before expensive periods

  svotc_heat_aggressiveness:
    name: "Heat aggressiveness"
    min: 0
    max: 5
    step: 1
    mode: slider
    # 0 = No extra heat, 5 = Maximum boost (−2.0°C offset)
    # Controls how much extra heat is added when comfort guard is active

  svotc_brake_hold_offset_c:
    name: "Brake hold offset (°C)"
    min: 0
    max: 20
    step: 0.5
    mode: box
    # Maximum offset during expensive periods (positive = less heat)

  # --- Dwell Time Settings (Price State Transitions) ---
  svotc_price_dwell_cheap_to_neutral_min:
    name: "Dwell cheap → neutral (min)"
    min: 0
    max: 120
    step: 1
    mode: box
    # How long price must stay above P30 before switching from cheap to neutral

  svotc_price_dwell_neutral_to_brake_min:
    name: "Dwell neutral → brake (min)"
    min: 0
    max: 120
    step: 1
    mode: box
    # How long price must stay above P80 before switching from neutral to brake

  svotc_price_dwell_brake_to_neutral_min:
    name: "Dwell brake → neutral (min)"
    min: 0
    max: 120
    step: 1
    mode: box
    # How long price must stay below P80 before switching from brake to neutral

  svotc_price_dwell_neutral_to_cheap_min:
    name: "Dwell neutral → cheap (min)"
    min: 0
    max: 120
    step: 1
    mode: box
    # How long price must stay below P30 before switching from neutral to cheap

  # --- Brake Phase Duration Settings ---
  svotc_brake_rampup_duration_min:
    name: "Brake ramp-up duration (min)"
    min: 1
    max: 180
    step: 1
    mode: box
    # Time to gradually increase offset from 0 to hold_offset

  svotc_brake_hold_duration_min:
    name: "Brake hold duration (min)"
    min: 1
    max: 120
    step: 1
    mode: box
    # Time to maintain maximum offset during expensive period

  svotc_brake_rampdown_duration_min:
    name: "Brake ramp-down duration (min)"
    min: 1
    max: 180
    step: 1
    mode: box
    # Time to gradually decrease offset from hold_offset to 0

  # --- Rate Limiting ---
  svotc_max_delta_per_step_c:
    name: "Max delta per step"
    min: 0.05
    max: 1.0
    step: 0.01
    mode: box
    # Maximum change in offset per minute (prevents sudden jumps)

  ##############################################################################
  # 1.2 SYSTEM STATE (Read-only - managed automatically by SVOTC)
  ##############################################################################

  # --- Engine Outputs (Read-only - shows current system state) ---
  svotc_requested_offset_c:
    name: "Requested offset (engine)"
    min: -10
    max: 10
    step: 0.1
    mode: box
    # What the engine wants to apply (before rate limiting)

  svotc_applied_offset_c:
    name: "Applied offset (ramp-limited)"
    min: -10
    max: 10
    step: 0.1
    mode: box
    # Actual offset being applied (after rate limiting)
    # This is what gets added to outdoor temperature

  ##############################################################################
  # 1.3 CONFIGURATION (Set once, rarely changed)
  ##############################################################################
input_text:
  # --- Entity Mapping (Configure your sensors) ---
  svotc_entity_indoor:
    name: "Indoor temperature entity"
#    initial: "sensor.inomhusmedel"             # <-- CHANGE TO YOUR SENSOR IN GUI
  # Your indoor temperature sensor

  svotc_entity_outdoor:
    name: "Outdoor temperature entity"
#    initial: "sensor.temperatur_nu"            # <-- CHANGE TO YOUR SENSOR IN GUI
  # Your outdoor temperature sensor

  svotc_entity_price:
    name: "Price entity (Nordpool)"
#    initial: "sensor.nordpool_tibber"          # <-- CHANGE TO YOUR SENSOR IN GUI
  # Your electricity price sensor
  # Must provide attributes: current_price + raw_today (list of {start, end, value}) + raw_tomorrow (list of {start, end, value})

  svotc_notify_service:
    name: "SVOTC Notify service"
#    initial: "notify.mobile_app_iphone13pro" # <-- CHANGE TO YOUR PHONE NOTIFY SERVICE IN GUI
    # Your Phone etc.    

  ##############################################################################
  # 1.4 INTERNAL STATE (Read-only - managed automatically by SVOTC)
  ##############################################################################
  # --- State Machine Memory (Read-only - internal state tracking) ---
  svotc_last_price_state:
    name: "Stable price state (authoritative)"
#    initial: "neutral"
    # Current stable price state: off | cheap | neutral | brake

  svotc_pending_price_state:
    name: "Pending price state (dwell)"
#    initial: "neutral"
    # Price state waiting to become stable (after dwell time)

  svotc_brake_phase:
    name: "Brake phase"
#    initial: "idle"
    # Current brake phase: idle | ramping_up | holding | ramping_down

  svotc_reason_code:
    name: "Reason code"
#    initial: "INIT"
    # Explains why engine made current decision
    # Possible values:
    #   INIT                    - Initial state
    #   OFF                     - Mode = Off
    #   PASS_THROUGH            - Mode = PassThrough (no offset)
    #   COMFORT_ONLY            - Mode = ComfortOnly
    #   MISSING_INPUTS_FREEZE   - Sensors unavailable, offset frozen
    #   COMFORT_GUARD           - Indoor temp too low, heating boost
    #   MCP_BLOCKS_BRAKE        - Comfort guard overrides price brake
    #   PRICE_BRAKE             - Expensive price, reducing heat
    #   NEUTRAL                 - Normal operation

input_datetime:
  # --- Timestamps (Read-only - tracks state change timing) ---
  svotc_last_price_state_changed:
    name: "Pending state since"
    has_date: true
    has_time: true
    # When current pending price state started

  svotc_brake_phase_changed:
    name: "Brake phase changed"
    has_date: true
    has_time: true
    # When current brake phase started

  svotc_engine_last_run:
    name: "Engine last run"
    has_date: true
    has_time: true

input_boolean:
  svotc_comfort_guard_enabled:
    name: "Comfort guard (protect indoor temp)"
    icon: mdi:shield-home

################################################################################
## 2. Sensing & Planning Sensors (NO memory via this.state)
################################################################################

template:
  - sensor:
    ############################################################################
    # 2.1 Indoor temperature (validated)
    #     Range: 10-35°C, sanity checked
    ############################################################################
      - name: "SVOTC Src Indoor"
        unique_id: svotc_src_indoor
        unit_of_measurement: "°C"
        device_class: temperature
        state_class: measurement
        state: >
          {% set ent = states('input_text.svotc_entity_indoor') %}
          {% if ent in ['unknown','unavailable',''] %}
            {{ none }}
          {% else %}
            {% set v = states(ent) | float(none) %}
            {{ v | round(2) if v is number and 10 <= v <= 35 else none }}
          {% endif %}
        availability: >
          {% set ent = states('input_text.svotc_entity_indoor') %}
          {% if ent in ['unknown','unavailable',''] %}
            false
          {% else %}
            {{ states(ent) | float(none) is number }}
          {% endif %}

    ############################################################################
    # 2.2 Outdoor temperature (validated)
    #     Range: -50 to +50°C, sanity checked
    ############################################################################
      - name: "SVOTC Src Outdoor"
        unique_id: svotc_src_outdoor
        unit_of_measurement: "°C"
        device_class: temperature
        state_class: measurement
        state: >
          {% set ent = states('input_text.svotc_entity_outdoor') %}
          {% if ent in ['unknown','unavailable',''] %}
            {{ none }}
          {% else %}
            {% set v = states(ent) | float(none) %}
            {{ v | round(2) if v is number and -50 <= v <= 50 else none }}
          {% endif %}
        availability: >
          {% set ent = states('input_text.svotc_entity_outdoor') %}
          {% if ent in ['unknown','unavailable',''] %}
            false
          {% else %}
            {{ states(ent) | float(none) is number }}
          {% endif %}

    ############################################################################
    # 2.3 Current price (validated) -> "source of truth"
    #     Range: -1 to 20 SEK/kWh, sanity checked
    ############################################################################
      - name: "SVOTC Src Current Price"
        unique_id: svotc_src_current_price
        unit_of_measurement: "SEK/kWh"
        state: >
          {% set ent = states('input_text.svotc_entity_price') %}
          {% if ent in ['unknown','unavailable','none',''] %}
            {{ none }}
          {% else %}
            {% set p = state_attr(ent, 'current_price') %}
            {{ p | round(3) if p is number and -1 <= p <= 20 else none }}
          {% endif %}
        availability: >
          {% set ent = states('input_text.svotc_entity_price') %}
          {{ ent not in ['unknown','unavailable','none',''] and state_attr(ent, 'current_price') is number }}

    ############################################################################
    # 2.3b Current price (mirror) -> for dashboards/legacy references
    ############################################################################
      - name: "SVOTC Current price"
        unique_id: svotc_current_price
        unit_of_measurement: "SEK/kWh"
        state: "{{ states('sensor.svotc_src_current_price') }}"
        availability: "{{ states('sensor.svotc_src_current_price') not in ['unknown','unavailable','none',''] }}"

    ############################################################################
    # 2.4 Dynamic target temperature
    #     Uses comfort temperature setting as target
    ############################################################################
      - name: "SVOTC Dynamic target temperature"
        unique_id: svotc_dynamic_target_temperature
        unit_of_measurement: "°C"
        device_class: temperature
        state: "{{ states('input_number.svotc_comfort_temperature') | float(21) | round(2) }}"

    ############################################################################
    # 2.5 Percentiles P30/P80 from raw_today + raw_tomorrow
    #     NO memory fallback; outputs none when insufficient data (< 20 prices)
    ############################################################################
      - name: "SVOTC P30"
        unique_id: svotc_p30
        unit_of_measurement: "SEK/kWh"
        state: >
          {% set ent = states('input_text.svotc_entity_price') %}
          {% if ent in ['unknown','unavailable','none',''] %}
            {{ none }}
          {% else %}
            {% set today = state_attr(ent, 'raw_today') | default([], true) %}
            {% set tomorrow = state_attr(ent, 'raw_tomorrow') | default([], true) %}
            {% set prices = (today + tomorrow) | map(attribute='value') | select('number') | list %}
            {% if prices | length >= 20 %}
              {% set s = prices | sort %}
              {% set idx = ((s | length - 1) * 0.30) | round(0, 'half_up') | int %}
              {{ s[idx] | round(3) }}
            {% else %}
              {{ none }}
            {% endif %}
          {% endif %}
        availability: >
          {% set ent = states('input_text.svotc_entity_price') %}
          {{ ent not in ['unknown','unavailable','none',''] }}

      - name: "SVOTC P80"
        unique_id: svotc_p80
        unit_of_measurement: "SEK/kWh"
        state: >
          {% set ent = states('input_text.svotc_entity_price') %}
          {% if ent in ['unknown','unavailable','none',''] %}
            {{ none }}
          {% else %}
            {% set today = state_attr(ent, 'raw_today') | default([], true) %}
            {% set tomorrow = state_attr(ent, 'raw_tomorrow') | default([], true) %}
            {% set prices = (today + tomorrow) | map(attribute='value') | select('number') | list %}
            {% if prices | length >= 20 %}
              {% set s = prices | sort %}
              {% set idx = ((s | length - 1) * 0.80) | round(0, 'half_up') | int %}
              {{ s[idx] | round(3) }}
            {% else %}
              {{ none }}
            {% endif %}
          {% endif %}
        availability: >
          {% set ent = states('input_text.svotc_entity_price') %}
          {{ ent not in ['unknown','unavailable','none',''] }}

    ############################################################################
    # 2.6 Raw price state (instant, NO dwell, NO memory)
    #     Thresholds: current_price vs P30/P80
    #     Output: "off" | "cheap" | "neutral" | "brake"
    ############################################################################
      - name: "SVOTC Raw price state"
        unique_id: svotc_raw_price_state
        state: >
          {% set mode = states('input_select.svotc_mode') %}
          {% if mode in ['Off','PassThrough','ComfortOnly'] %}
            off
          {% else %}
            {% set p = states('sensor.svotc_src_current_price') | float(none) %}
            {% set p30 = states('sensor.svotc_p30') | float(none) %}
            {% set p80 = states('sensor.svotc_p80') | float(none) %}

            {% if p is not number or p30 is not number or p80 is not number %}
              neutral
            {% elif p > p80 %}
              brake
            {% elif p < p30 %}
              cheap
            {% else %}
              neutral
            {% endif %}
          {% endif %}  
    ############################################################################
    # 2.7 Forward look: Minutes to next brake start
    #     Scans raw_today + raw_tomorrow for next interval where price > P80
    #     Output: 0 if currently in expensive period, otherwise minutes until next
    ############################################################################
      - name: "SVOTC Minutes to next brake start"
        unique_id: svotc_minutes_to_next_brake_start
        unit_of_measurement: "min"
        state: >
          {% set ent = states('input_text.svotc_entity_price') %}
          {% set p80 = states('sensor.svotc_p80') | float(none) %}
          {% if ent in ['unknown','unavailable','none',''] or p80 is not number %}
            999
          {% else %}
            {% set today = state_attr(ent, 'raw_today') | default([], true) %}
            {% set tomorrow = state_attr(ent, 'raw_tomorrow') | default([], true) %}
            {% set combined = today + tomorrow %}
            {% set now_ts = as_timestamp(now()) %}
            {% set ns = namespace(best=none, in_expensive=false) %}

            {% for it in combined %}
              {% set v = it.value | float(none) %}
              {% set s = as_timestamp(it.start, default=none) if it.start is defined else none %}
              {% set e = as_timestamp(it.end,   default=none) if it.end   is defined else none %}
              {% if v is number and s is number and e is number and s <= now_ts < e and v > p80 %}
                {% set ns.in_expensive = true %}
              {% endif %}
            {% endfor %}

            {% if ns.in_expensive %}
              0
            {% else %}
              {% for it in combined %}
                {% set v = it.value | float(none) %}
                {% set s = as_timestamp(it.start, default=none) if it.start is defined else none %}
                {% if v is number and s is number and s >= now_ts and v > p80 %}
                  {% set mins = (s - now_ts) / 60 %}
                  {% if ns.best is none or mins < ns.best %}
                    {% set ns.best = mins %}
                  {% endif %}
                {% endif %}
              {% endfor %}
              {{ ns.best | round(1) if ns.best is not none else 999 }}
            {% endif %}
          {% endif %}
        availability: >
          {% set ent = states('input_text.svotc_entity_price') %}
          {{ ent not in ['unknown','unavailable','none',''] }}

    ############################################################################
    # 2.8 Prebrake strength calculation
    #     2.8a: Maps brake aggressiveness (0-5) to prebrake window (0-120 min)
    #     2.8b: Calculates linear ramp: strength = (window - mins) / window
    ############################################################################
      - name: "SVOTC Prebrake window (min)"
        unique_id: svotc_prebrake_window_min
        unit_of_measurement: "min"
        state: >
          {% set mode = states('input_select.svotc_mode') %}
          {% set a = 2 if mode == 'Simple' else (states('input_number.svotc_brake_aggressiveness') | int(0)) %}
          {% set mapper = {0:0, 1:30, 2:60, 3:90, 4:105, 5:120} %}
          {{ mapper.get(a, 0) }}

      - name: "SVOTC Prebrake strength"
        unique_id: svotc_prebrake_strength
        state: >
          {% set window = states('sensor.svotc_prebrake_window_min') | float(0) %}
          {% set mins = states('sensor.svotc_minutes_to_next_brake_start') | float(999) %}
          {% if window > 0 and mins <= window %}
            {{ ((window - mins) / window) | round(3) | clamp(0, 1) }}
          {% else %}
            0
          {% endif %}

    ############################################################################
    # 2.9 Virtual outdoor temperature (final output)
    #     Real outdoor + applied offset → sent to heat pump
    #     Clamped to -50°C to +50°C for safety
    ############################################################################
      - name: "SVOTC Virtual outdoor temperature"
        unique_id: svotc_virtual_outdoor_temperature
        unit_of_measurement: "°C"
        device_class: temperature
        state: >
          {% set out = states('sensor.svotc_src_outdoor') | float(none) %}
          {% set off = states('input_number.svotc_applied_offset_c') | float(0) %}
          {% if out is number %}
            {{ (out + off) | clamp(-50, 50) | round(2) }}
          {% else %}
            {{ none }}
          {% endif %}

  - binary_sensor:
    ############################################################################
    # 2.10 Binary sensors (diagnostics & control)
    ############################################################################

    ############################################################################
    # 2.10a Comfort guard (with hysteresis)
    #      Activates when indoor temp drops below (target - activate_below)
    #      Deactivates when indoor temp rises above (target - deactivate_above)
    ############################################################################
      - name: "SVOTC Comfort guard active"
        unique_id: svotc_comfort_guard_active
        state: >
          {% set enabled = is_state('input_boolean.svotc_comfort_guard_enabled','on') %}
          {% if not enabled %}
            false
          {% else %}
            {% set mode = states('input_select.svotc_mode') %}
            {% set indoor = states('sensor.svotc_src_indoor') | float(none) %}
            {% set target = states('sensor.svotc_dynamic_target_temperature') | float(none) %}

            {# Simple (Ngenic-style) internal defaults #}
            {% set activate_below =
                0.8 if mode == 'Simple'
                else (states('input_number.svotc_comfort_guard_activate_below_c') | float(1.0))
            %}
            {% set deactivate_above =
                0.3 if mode == 'Simple'
                else (states('input_number.svotc_comfort_guard_deactivate_above_c') | float(0.4))
            %}

            {% set was_on = is_state('binary_sensor.svotc_comfort_guard_active','on') %}

            {% if indoor is not number or target is not number %}
              {{ was_on }}
            {% else %}
              {% set activate_threshold = target - activate_below %}
              {% set deactivate_threshold = target - deactivate_above %}

              {% if was_on %}
                {{ indoor < deactivate_threshold }}
              {% else %}
                {{ indoor < activate_threshold }}
              {% endif %}
            {% endif %}
          {% endif %}

    ############################################################################
    # 2.10b Inputs healthy (CORE) - does NOT depend on price
    #       Only checks indoor & outdoor temperature sensors
    ############################################################################
      - name: "SVOTC Inputs healthy"
        unique_id: svotc_inputs_healthy
        state: >
          {{ states('sensor.svotc_src_indoor') not in ['unknown','unavailable','none',''] 
          and states('sensor.svotc_src_outdoor') not in ['unknown','unavailable','none',''] }}

    ############################################################################
    # 2.10c Price available (diagnostic only)
    #       Indicates if price sensor is working
    ############################################################################
      - name: "SVOTC Price available"
        unique_id: svotc_price_available
        state: >
          {{ states('sensor.svotc_src_current_price') not in ['unknown','unavailable','none',''] }}

    ############################################################################
    # DIAGNOSTICS SUMMARY:
    #   - svotc_inputs_healthy: Indoor & outdoor sensors OK
    #   - svotc_price_available: Price sensor OK (diagnostic only)
    #   - svotc_comfort_guard_active: Hysteresis-based comfort protection
    #   - svotc_reason_code: Current engine decision reason
    ############################################################################

################################################################################
## 3. Automations (State Machines & Control Loops)
##
## FLOW DIAGRAM:
##   Raw Price → [Dwell 3.1] → Stable Price → [Brake Phase 3.2] → Phase
##                                                ↓
##   Indoor Temp → [Comfort Guard] → Comfort Term ──┐
##                                                   ├→ [Engine 3.3] → Applied Offset
##   Prebrake Strength → Price Term ────────────────┘
##
## STATE MACHINES:
##   - 3.1: Price dwell (cheap ⇄ neutral ⇄ brake with hysteresis)
##   - 3.2: Brake phases (idle → ramping_up → holding → ramping_down → idle)
##   - 3.3: Engine (requested → ramp-limited → applied)
##   - 3.4 Notify (diagnostics) - alert only if bad state persists
################################################################################

automation:
    ############################################################################
    # 3.1 Price dwell (raw → stable) [NON-NEGOTIABLE layer]
    #     Prevents rapid state changes by requiring dwell time before accepting
    #     new price state. Uses separate pending state and timestamp tracking.
    #     Triggers: Every 1 minutes OR when any input parameter changes OR when raw price state changes
    ############################################################################
  - alias: "SVOTC Price dwell"
    id: svotc_price_dwell
    mode: single
    trigger:
      - platform: time_pattern
        minutes: "/1"
      - platform: state
        entity_id: sensor.svotc_raw_price_state

    action:
      - variables:
          raw: "{{ states('sensor.svotc_raw_price_state') }}"
          stable: "{{ states('input_text.svotc_last_price_state') }}"
          pending: "{{ states('input_text.svotc_pending_price_state') }}"
          raw_valid: "{{ raw not in ['unknown','unavailable','none',''] }}"
          pending_valid: "{{ pending not in ['unknown','unavailable','none',''] }}"

      # If raw is invalid -> do nothing (freeze stable/pending)
      - choose:
          - conditions: "{{ not raw_valid }}"
            sequence:
              - stop: "Raw price state invalid -> freeze"

      # If raw changed -> update pending and timestamp (start dwell)
      - choose:
          - conditions: "{{ raw != pending }}"
            sequence:
              - service: input_text.set_value
                target:
                  entity_id: input_text.svotc_pending_price_state
                data:
                  value: "{{ raw }}"
              - service: input_datetime.set_datetime
                target:
                  entity_id: input_datetime.svotc_last_price_state_changed
                data:
                  datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}"

      # Calculate elapsed minutes since pending started
      - variables:
          ts: "{{ as_timestamp(states('input_datetime.svotc_last_price_state_changed'), default=none) }}"
          elapsed_min: >
            {% if ts is number %}
              {{ (as_timestamp(now()) - ts) / 60 }}
            {% else %}
              999
            {% endif %}
          dwell_needed_min: >
            {% if stable == 'cheap' and pending == 'neutral' %}
              {{ states('input_number.svotc_price_dwell_cheap_to_neutral_min') | float(0) }}
            {% elif stable == 'neutral' and pending == 'brake' %}
              {{ states('input_number.svotc_price_dwell_neutral_to_brake_min') | float(0) }}
            {% elif stable == 'brake' and pending == 'neutral' %}
              {{ states('input_number.svotc_price_dwell_brake_to_neutral_min') | float(0) }}
            {% elif stable == 'neutral' and pending == 'cheap' %}
              {{ states('input_number.svotc_price_dwell_neutral_to_cheap_min') | float(0) }}
            {% else %}
              0
            {% endif %}

      # Accept pending as stable only after dwell time (pending must be valid)
      - choose:
          - conditions: >
              {{ pending_valid and pending != stable and elapsed_min | float(0) >= dwell_needed_min | float(0) }}
            sequence:
              - service: input_text.set_value
                target:
                  entity_id: input_text.svotc_last_price_state
                data:
                  value: "{{ pending }}"

    ############################################################################
    # 3.2 Brake phase controller (phase memory; avoid unnecessary writes)
    #     Manages brake phase transitions with precise timing
    #     Phases: idle → ramping_up → holding → ramping_down → idle
    #     Triggers: Every 1 minute OR when stable price/phase changes
    ############################################################################
  - alias: "SVOTC Brake phase controller"
    id: svotc_brake_phase_controller
    mode: single
    trigger:
      - platform: time_pattern
        minutes: "/1"
      - platform: state
        entity_id:
          - input_text.svotc_last_price_state
          - input_text.svotc_brake_phase

    action:
      - variables:
          price_state: "{{ states('input_text.svotc_last_price_state') }}"
          phase: "{{ states('input_text.svotc_brake_phase') }}"
          phase_ts: "{{ as_timestamp(states('input_datetime.svotc_brake_phase_changed'), default=none) }}"
          elapsed_min: >
            {% if phase_ts is number %} {{ (as_timestamp(now()) - phase_ts) / 60 }} {% else %} 999 {% endif %}
          rampup: "{{ states('input_number.svotc_brake_rampup_duration_min') | float(30) }}"
          hold_min: "{{ states('input_number.svotc_brake_hold_duration_min') | float(1) }}"
          rampdown: "{{ states('input_number.svotc_brake_rampdown_duration_min') | float(45) }}"

      # ------------------------------------------------------------
      # A) WHEN price_state == brake:
      #    - Never allow idle
      #    - Only ramp_up -> holding by time
      # ------------------------------------------------------------
      - choose:

          # brake starts: idle -> ramping_up
          - conditions: "{{ price_state == 'brake' and phase == 'idle' }}"
            sequence:
              - service: input_text.set_value
                target: { entity_id: input_text.svotc_brake_phase }
                data: { value: "ramping_up" }
              - service: input_datetime.set_datetime
                target: { entity_id: input_datetime.svotc_brake_phase_changed }
                data: { datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}" }
              - stop: true

          # brake returns while ramping_down: cancel rampdown -> ramping_up
          - conditions: "{{ price_state == 'brake' and phase == 'ramping_down' }}"
            sequence:
              - service: input_text.set_value
                target: { entity_id: input_text.svotc_brake_phase }
                data: { value: "ramping_up" }
              - service: input_datetime.set_datetime
                target: { entity_id: input_datetime.svotc_brake_phase_changed }
                data: { datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}" }
              - stop: true

          # ramping_up -> holding when rampup done
          - conditions: "{{ price_state == 'brake' and phase == 'ramping_up' and elapsed_min >= rampup }}"
            sequence:
              - service: input_text.set_value
                target: { entity_id: input_text.svotc_brake_phase }
                data: { value: "holding" }
              - service: input_datetime.set_datetime
                target: { entity_id: input_datetime.svotc_brake_phase_changed }
                data: { datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}" }
              - stop: true

      # ------------------------------------------------------------
      # B) WHEN price_state != brake:
      #    - ramping_up/holding -> ramping_down (option: min-hold)
      #    - ramping_down -> idle when rampdown done
      # ------------------------------------------------------------
      - choose:

          # If holding but we haven't held at least hold_min minutes, keep holding
          - conditions: "{{ price_state != 'brake' and phase == 'holding' and elapsed_min < hold_min }}"
            sequence:
              - stop: true

          # If leaving brake from ramping_up or holding -> ramping_down
          - conditions: "{{ price_state != 'brake' and phase in ['ramping_up','holding'] }}"
            sequence:
              - service: input_text.set_value
                target: { entity_id: input_text.svotc_brake_phase }
                data: { value: "ramping_down" }
              - service: input_datetime.set_datetime
                target: { entity_id: input_datetime.svotc_brake_phase_changed }
                data: { datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}" }
              - stop: true

          # ramping_down -> idle when rampdown complete
          - conditions: "{{ price_state != 'brake' and phase == 'ramping_down' and elapsed_min >= rampdown }}"
            sequence:
              - service: input_text.set_value
                target: { entity_id: input_text.svotc_brake_phase }
                data: { value: "idle" }
              - service: input_datetime.set_datetime
                target: { entity_id: input_datetime.svotc_brake_phase_changed }
                data: { datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}" }
    ############################################################################
    # 3.3 SVOTC Engine (Control loop: requested → ramp-limited applied)
    #     Core control logic that calculates and applies offset changes
    #     - Calculates comfort_term (negative = more heat when guard active)
    #     - Calculates price_term (positive = less heat during expensive)
    #     - Applies rate limiting (max_delta_per_step_c)
    #     - FREEZE mode when inputs unhealthy (no vertical jumps)
    #     - Triggers: Every 2 minutes OR when any input parameter changes
    ############################################################################
  - alias: "SVOTC Engine"
    id: svotc_engine
    mode: single
    trigger:
      - platform: time_pattern
        minutes: "/2"
      - platform: state
        entity_id:
          - input_select.svotc_mode
          - sensor.svotc_prebrake_strength
          - binary_sensor.svotc_comfort_guard_active
          - input_boolean.svotc_comfort_guard_enabled
          - input_number.svotc_brake_hold_offset_c
          - input_number.svotc_heat_aggressiveness
          - input_number.svotc_max_delta_per_step_c

    variables:
      # --- Anti-storm throttle ---
      last_run_ts: "{{ as_timestamp(states('input_datetime.svotc_engine_last_run'), default=none) }}"
      since_last_s: >
        {% if last_run_ts is number %}
          {{ as_timestamp(now()) - last_run_ts }}
        {% else %}
          999
        {% endif %}

      mode: "{{ states('input_select.svotc_mode') }}"
      healthy: "{{ is_state('binary_sensor.svotc_inputs_healthy','on') }}"
      pre: "{{ states('sensor.svotc_prebrake_strength') | float(0) }}"
      guard: >
        {{ is_state('binary_sensor.svotc_comfort_guard_active','on')
        and is_state('input_boolean.svotc_comfort_guard_enabled','on') }}

      hold_offset: >
        {{ 3.0 if mode == 'Simple'
        else (states('input_number.svotc_brake_hold_offset_c') | float(0)) }}

      heat_aggr: >
        {{ 2 if mode == 'Simple'
        else (states('input_number.svotc_heat_aggressiveness') | int(0)) }}

      max_delta: >
        {{ 0.10 if mode == 'Simple'
        else (states('input_number.svotc_max_delta_per_step_c') | float(0.2)) }}

      req_min: "{{ state_attr('input_number.svotc_requested_offset_c','min') | float(-10) }}"
      req_max: "{{ state_attr('input_number.svotc_requested_offset_c','max') | float(10) }}"
      app_min: "{{ state_attr('input_number.svotc_applied_offset_c','min') | float(-10) }}"
      app_max: "{{ state_attr('input_number.svotc_applied_offset_c','max') | float(10) }}"

      comfort_term: >
        {% if mode in ['Off','PassThrough'] %} 0
        {% elif mode in ['Smart','Simple','ComfortOnly'] and guard %} {{ -(heat_aggr * 0.4) }}
        {% else %} 0 {% endif %}

      price_term: >
        {% if mode not in ['Smart','Simple'] or guard %} 0
        {% else %} {{ hold_offset * pre }} {% endif %}

      requested: "{{ (comfort_term + price_term) | clamp(req_min, req_max) | round(2) }}"
      prev_applied: "{{ states('input_number.svotc_applied_offset_c') | float(requested) }}"
      delta: "{{ requested - prev_applied }}"

      next_applied: >
        {% if delta > max_delta %} {{ (prev_applied + max_delta) | clamp(app_min, app_max) | round(2) }}
        {% elif delta < -max_delta %} {{ (prev_applied - max_delta) | clamp(app_min, app_max) | round(2) }}
        {% else %} {{ requested | clamp(app_min, app_max) | round(2) }} {% endif %}

      reason: >
        {% if mode == 'Off' %} OFF
        {% elif not healthy %} MISSING_INPUTS_FREEZE
        {% elif mode == 'PassThrough' %} PASS_THROUGH
        {% elif guard and pre > 0 and mode in ['Smart','Simple'] %} MCP_BLOCKS_BRAKE
        {% elif guard %} COMFORT_GUARD
        {% elif pre > 0 and mode in ['Smart','Simple'] %} PRICE_BRAKE
        {% elif mode == 'ComfortOnly' %} COMFORT_ONLY
        {% else %} NEUTRAL {% endif %}

    action:
      # --- THROTTLE: block trigger-storms (only allow 1 run per 30 seconds) ---
      - choose:
          - conditions: "{{ since_last_s < 30 }}"
            sequence:
              - stop: "Engine throttled (anti-storm)"

      # Record actual run timestamp (do this after throttle passes)
      - service: input_datetime.set_datetime
        target:
          entity_id: input_datetime.svotc_engine_last_run
        data:
          datetime: "{{ now().strftime('%Y-%m-%d %H:%M:%S') }}"

      - choose:
          - conditions: "{{ not healthy and mode in ['Smart','Simple','ComfortOnly'] }}"
            sequence:
              - service: input_number.set_value
                target:
                  entity_id: input_number.svotc_requested_offset_c
                data:
                  value: 0
              - service: input_text.set_value
                target:
                  entity_id: input_text.svotc_reason_code
                data:
                  value: "MISSING_INPUTS_FREEZE"
              - stop: "Inputs not healthy"

      - service: input_number.set_value
        target:
          entity_id: input_number.svotc_requested_offset_c
        data:
          value: "{{ requested }}"

      - service: input_number.set_value
        target:
          entity_id: input_number.svotc_applied_offset_c
        data:
          value: "{{ next_applied }}"

      - service: input_text.set_value
        target:
          entity_id: input_text.svotc_reason_code
        data:
          value: "{{ reason }}"

    ############################################################################
    ## 3.4 Notify (diagnostics) - alert only if bad state persists
    ############################################################################
  - alias: "SVOTC Notify: missing inputs/price"
    id: svotc_notify_missing_inputs_price_delayed
    mode: single

    trigger:
      # BAD: inputs_healthy OFF for X minutes
      - platform: state
        entity_id: binary_sensor.svotc_inputs_healthy
        to: "off"
        for:
          minutes: 3

      # BAD: price_available OFF for X minutes
      - platform: state
        entity_id: binary_sensor.svotc_price_available
        to: "off"
        for:
          minutes: 3

      # OK: both ON for X minutes (avoid flapping)
      - platform: template
        for:
          minutes: 2
        value_template: >
          {{ is_state('binary_sensor.svotc_inputs_healthy','on')
             and is_state('binary_sensor.svotc_price_available','on') }}

      # WARN: comfort guard disabled for X minutes
      - platform: state
        entity_id: input_boolean.svotc_comfort_guard_enabled
        to: "off"
        for:
          minutes: 5

    action:
      - variables:
          # Notify service from helper (fallback if empty/unavailable)
          notify_svc: >-
            {% set s = states('input_text.svotc_notify_service') %}
            {{ s if s not in ['unknown','unavailable',''] else 'notify.notify' }}

          # Mapping (what user configured)
          indoor_map: "{{ states('input_text.svotc_entity_indoor') }}"
          outdoor_map: "{{ states('input_text.svotc_entity_outdoor') }}"
          price_map: "{{ states('input_text.svotc_entity_price') }}"

          # Validated sources (what SVOTC actually sees)
          src_indoor: "{{ states('sensor.svotc_src_indoor') }}"
          src_outdoor: "{{ states('sensor.svotc_src_outdoor') }}"
          src_price: "{{ states('sensor.svotc_src_current_price') }}"

          inputs_ok: "{{ is_state('binary_sensor.svotc_inputs_healthy', 'on') }}"
          price_ok: "{{ is_state('binary_sensor.svotc_price_available', 'on') }}"

          guard_enabled: "{{ is_state('input_boolean.svotc_comfort_guard_enabled', 'on') }}"

          missing_list: >-
            {% set miss = [] %}
            {% if indoor_map in ['unknown','unavailable',''] %}{% set miss = miss + ['indoor mapping'] %}{% endif %}
            {% if outdoor_map in ['unknown','unavailable',''] %}{% set miss = miss + ['outdoor mapping'] %}{% endif %}
            {% if price_map in ['unknown','unavailable',''] %}{% set miss = miss + ['price mapping'] %}{% endif %}
            {{ miss | join(', ') if miss | length > 0 else 'none' }}

      - choose:
          # WARN: Comfort Guard disabled (awareness notice)
          - conditions: "{{ trigger.entity_id == 'input_boolean.svotc_comfort_guard_enabled' and not guard_enabled }}"
            sequence:
              - service: "{{ notify_svc }}"
                data:
                  title: "SVOTC: Comfort Guard is OFF"
                  message: >-
                    (Has been OFF for at least 5 minutes)

                    You have disabled Comfort Guard / Prioritize comfort.
                    SVOTC can now prioritize price savings more aggressively,
                    and indoor temperature may drop noticeably during expensive hours.

                    Current:
                      mode={{ states('input_select.svotc_mode') }},
                      reason={{ states('input_text.svotc_reason_code') }},
                      indoor={{ src_indoor }}°C (target {{ states('sensor.svotc_dynamic_target_temperature') }}°C)

          # BAD state
          - conditions: "{{ not inputs_ok or not price_ok }}"
            sequence:
              - service: "{{ notify_svc }}"
                data:
                  title: "SVOTC: Missing data"
                  message: >-
                    (Has been bad for at least 3 minutes)

                    Status:
                      inputs_healthy={{ states('binary_sensor.svotc_inputs_healthy') }},
                      price_available={{ states('binary_sensor.svotc_price_available') }}

                    Missing mappings: {{ missing_list }}

                    Mapping:
                      indoor={{ indoor_map }},
                      outdoor={{ outdoor_map }},
                      price={{ price_map }}

                    Sources:
                      svotc_src_indoor={{ src_indoor }},
                      svotc_src_outdoor={{ src_outdoor }},
                      svotc_src_current_price={{ src_price }}

          # Recovery / OK again
          - conditions: "{{ inputs_ok and price_ok }}"
            sequence:
              - service: "{{ notify_svc }}"
                data:
                  title: "SVOTC: OK again"
                  message: "(Has been OK for at least 2 minutes) Inputs + price data are healthy again."
################################################################################
## END OF FILE
################################################################################
